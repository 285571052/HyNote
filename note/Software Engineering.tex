\documentclass[UTF8,a4paper]{ctexart}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr,hyperref,amsmath}
\pagestyle{fancy}
\hypersetup{hidelinks}

\lhead{\bfseries \leftmark}
\chead{}
\rhead{SCUT}
\lfoot{\url{https://github.com/285571052}}
\cfoot{qhy}
\rfoot{\thepage}
\setlength{\headheight}{13pt}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\setlength{\parindent}{0pt}
\newcommand{\spaceline}{\vspace{\baselineskip}}

\author{ qhy }
\date{\today}
\title{软件工程}

\begin{document}
  \maketitle
  \tableofcontents
  \newpage

  \section{介绍}
  "软件"的概念、原则、方法、思想

  摩尔定律?软件危机?

  \textbf{什么是软件工程?}

  工程:起源于建筑行业,与建筑行业类似,从低到高遵循一定方法进行搭建,从工程的角度(使用工程的思想)对软件开发进行管理。

  \textbf{软件工程包括两大部分}
  \begin{itemize}
    \item [1.] 方法论

      软件生命周期
    \item [2.] 建模

      包括需求分析和软件设计
  \end{itemize}

  \textbf{为什么需要软件工程?}

  因为软件危机(硬件快速发展,软件发展滞后,且开发出的软件容易出问题,开发成本高,可维护性差),
  所以需要软件工程。主要体现为规范化和文档化。

  注:规范化和文档化,在各个阶段的体现并不完全相同。

  瀑布模型,60-70年代,重量级开发方法

  之后逐渐降低对文档的要求(通过规范来降低文档的要求)

  \textbf{软件工程的关键是使用 UML 进行建模}

  UML于97年提出,是公认的标准规范描述

  \section{软件危机}
  \textbf{软件危机:}
  \begin{itemize}
    \item 成本高
    \item 软件质量得不到拨正
    \item 计算机软硬费用比
    \item 进度难以控制
    \item 维护困难
  \end{itemize}

  软件危机无非是关于时间、成本、质量这三个方面的问题。

  \spaceline
  质量包括可靠性、安全性、可维护性、可移植性等方面。

  \spaceline
  \textbf{可靠性:}99.99\%,表示一年之内正常工作的概率是99.99\%,或一年之内故障的概率是0.01\%

  \spaceline
  \textbf{软件危机的解决办法:}主要分为两个方面:

  $\left \{\begin{array}{l}
    \text{从管理的角度}\left \{\begin{array}{l}
    \text{文档的标准化}\\
    \text{软件开发的过程的研究}\\
    \text{人们的交流方式}
    \end{array}\right .
    \\
    \text{软件开发方法的研究} \left \{ \begin{array}{l}
    \text{结构化开发方法}\\
    \text{面向对象开发方法}
    \end{array} \right .
  \end{array}\right .$

  管理是影响软件项目成功开发的全局性因素,而技术只是影响局部。\spaceline

  \textbf{结构化与面向对象的区别?}\\
  解决问题分为两个阶段:
  \begin{itemize}
    \item 问题分析
    \item 求解(编码)
  \end{itemize}

  问题分析中,结构化与面向对象都采用相同的层次化的思想,都是自顶向下逐层细化问题。\\
  而两者的区别主要在于编码部分,结构化采用自底向上的编码方式,而面向对象则是采用从中间向两边编码的方式。

  \spaceline
  \textbf{软件工程的三个要素:}
  \begin{itemize}
    \item 工具
    \item 方法
    \item 过程\\
    工具与方法的综合使用
  \end{itemize}

  \spaceline
  $\text{软件生命周期}\left \{\begin{array}{l}
  \text{软件定义} \left \{\begin{array}{l}
    \text{问题分析}\\
    \text{可行性研究}\\
    \text{需求分析}
  \end{array} \right .\\
  \text{软件开发} \left \{\begin{array}{l}
    \text{总体设计,单元测试}\\
    \text{详细设计,综合测试}\\
    \text{编码}
  \end{array} \right .\\
  \text{运行维护:持续满足用户需求}
  \end{array} \right .$

  \spaceline
  \textbf{描述bug的术语:}
  \begin{itemize}
    \item 错误\\
    当人们在进行软件开发活动的过程中,出错时,例如设计人员错误理解用户需求
    \item 故障\\
    非正常或非期望的工作状态(比如异常?)
    \item 失效\\
    指系统违背了它应有的行为
  \end{itemize}

  \spaceline
  \textbf{软件质量的各种视角:}(\color{red} ppt)

  个人利益不同,评价标准也不同。

  \spaceline
  \textbf{什么是好的软件?}包括以下三个方面
  \begin{itemize}
    \item 产品的质量\\
    产本本身的质量
    \item 过程的质量\\
    决定一个公司是否能持续的产出高质产品
    \item 商业环境背景下产品的质量
  \end{itemize}

\section{UML}

\textbf{UML体系结构视图:}
\begin{itemize}
  \item 结构
  \item 行为
  \item 分组
  \item 注释
\end{itemize}

\textbf{UML基本构成:}
\begin{itemize}
  \item 基本模型元素
  \item 关系
  \item 模型图
\end{itemize}

\textbf{行为:}
\begin{itemize}
  \item 交互\\
  多对象的行为
  \item 状态机\\
  单个对象自身状态的变化
\end{itemize}

\textbf{关系:}
\begin{itemize}
  \item 关联关系\\
  相互存在
  \item 依赖关系\\
  单向
  \item 泛化\\
  一般表现为继承关系,但泛化实际范围更广,它不要求两者之间有某种继承,只需要是特殊和一般的对比即可
  \item 实现关系\\
  比如:类与接口
\end{itemize}

\textbf{9种模型图:}...\\
也有说分10种,第10种是包图,它实际上是作用于前9种图使得更方便管理

\textbf{UML的建模规则:}...

\textbf{UML公共机制:}
\begin{itemize}
  \item 规则说明
  \item 通用划分
  \item 修饰
  \item 扩展机制
\end{itemize}

\textbf{扩展机制:}
\begin{itemize}
  \item 构造型\\
  构造新的元素
  \item 标记值\\
  构造型元素的属性(这个属性是更一般的属性,不一定是对象自身的特性,比如 版本号)
  \item 约束
\end{itemize}

\section{用例图}
用例图:面向对象进入第二阶段的标志

主要元素:$\left \{\begin{array}{l}\text{用例}\\\text{关系}\\\text{执行者} \end{array} \right .$

用例图在需求分析阶段给用户的需求进行可视化,代表是的交互的过程,而不是步骤

用例图应该站在用户的角度来描述

\spaceline
\textbf{执行者与用例之间的关系}:只有唯一的关联关系
主要的地方在于连线的箭头的方向,表示主被动的关系,当主被动关系不明确,或者相互的时候,则无箭头

\begin{itemize}
  \item 用例\\
  功能,子系统,以动名词为主
  \item 执行者\\
  由类元素构成的新元素,外部系统
  \item 系统边界\\
  界内为用例,界外为执行者
\end{itemize}

\textbf{关联关系:}\\
关联关系上的数目表示实例化对象之间的数目关系

\textbf{泛化关系:}一般与特殊的关系\\
A指向B,表示A继承自B\\
一般子类默认接受来自父类的关系

\subsection{用例之间关系}
用例之间的关系一般有以下4种:
\begin{itemize}
  \item 关联关系
  \item 泛化关系\\
  一般指同一功能的不同实现
  \item 包含关系\\
  指一个功能包含另一个功能,这个功能一般是不同用例时间出现的公共的行为\\
  包含关系更强调复用,但是直接用来列举步骤也没毛病,但是不合理(即不要把每个步骤都表示成用例)\\
  其次,尽量避免包含关系的嵌套
  \item 扩展关系\\
  可以看成是条件执行?\\
  B指向A,表示B扩展出A,B为A某种特殊情况发生才执行的用例(箭头由特殊指向一般)\\
  当有多个拓展关系的时候,把扩展节点描述在线上
\end{itemize}

\textbf{扩展与泛化的区别:}
\begin{itemize}
  \item 泛化关系的双方之间有内在的相同的东西
  \item 可以表示成泛化关系的双方也可以表示成扩展关系,反过来则不一定
\end{itemize}

{\color{red}后续补上用例, 执行者,系统边界,泛化关系的示意图}

\subsection{建立用例模型的主要工作}
建立用例模型的主要工作:
\begin{itemize}
  \item [1.]定义系统
  \item[2.]找出执行者
  \item[3.]找出用例
  \item[4.]描述用例
  \item[5.]用例的整理与加工
  \item[6.]验证模型
\end{itemize}

一般情况下,执行者放在系统边界的两边,主动的放左边,被动的放右边,上下一般留空。

\textbf{需求规格说明书 主要内容:}用例图+用例说明

\end{document}
