\documentclass[UTF8,a4paper]{ctexart}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr,hyperref,xcolor,amsmath,float,graphicx,cancel}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{automata}
\usetikzlibrary{arrows.meta}
\newcommand\hl{\bgroup\markoverwith
  {\textcolor[rgb]{0.9, 0.99, 0.9}{\rule[-.5ex]{2pt}{2.5ex}}}\ULon}

\pagestyle{fancy}
\hypersetup{hidelinks}

\lhead{\bfseries \leftmark}
\chead{}
\rhead{SCUT}
\lfoot{\url{https://github.com/285571052}}
\cfoot{qhy}
\rfoot{\thepage}
\setlength{\headheight}{13pt}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\setlength{\parindent}{0pt}
\newcommand{\spaceline}{\vspace{\baselineskip}}

\author{ qhy }
\date{\today}
\title{编译原理}
% \includeonly{}
\begin{document}
  \maketitle
  \tableofcontents
  \newpage
  \include{CompilerConstructionPrinciples-part1}
  \textbf{综合例题:}
  为正规文法$G[S]$\\
  $S = \to aA|bQ$\\
  $A \to aA|bB|b$\\
  $B\to bD|aQ$\\
  $Q\to aQ|bD|b$\\
  $D\to bB|aA$\\
  $E\to aB|bF$\\
  $F\to bD|aE|b$\\
  构造出相应的最小的DFA。
  \begin{itemize}
    \item 正规文法$\to$NFA\\
    \begin{tikzpicture}
        [every initial by arrow/.style={double distance = 3,-Implies}]
      \node[state,initial,initial text=]  (S)  {S};
      \node[state]  (AA) [above=of S,draw=none] {};
      \node[state]  (A) [right=of S] {A};
      \node[state]  (B) [right=of A] {B};
      \node[state]  (E) [below =of B] {E};
      \node[state]  (D) [below =of A] {D};
      \node[state,double]  (Z) [right=of B] {Z};
      \node[state]  (F) [below=of Z] {F};
      \node[state]  (BB) [below=of F,draw=none] {};
      \node[state]  (Q) [below =of S] {Q};

      \path [->] (S) edge   node[above]  {a} (A)
                  (S) edge   node[above]  {b} (Q)
                  (A) edge [loop above]  node[above]  {a} (A)
                  (A) edge   node[above]  {b} (B)
                  (A) edge [bend left]  node[above]  {b} (Z)
                  (B) edge [bend left]  node[above]  {b} (D)
                  %(B) edge [out = 135, in = 135]  node[above]  {a} (Q)
                  (B) edge [bend right]  node[above]  {a} (AA)
                  (AA) edge [bend right]  node[above]  {a} (Q)

                  (Q) edge [loop below]  node[above]  {a} (Q)
                  (Q) edge   node[above]  {b} (D)
                  %(Q) edge [out=-45 , in = -45]  node[above]  {b} (Z)
                  (Q) edge [bend right]  node[above]  {b} (BB)
                  (BB) edge [bend right]  node[above]  {b} (Z)

                  (D) edge   node[above]  {b} (B)
                  (D) edge   node[above]  {a} (A)
                  (E) edge   node[above]  {a} (B)
                  (E) edge [bend left]  node[above]  {b} (F)
                  (F) edge [bend left]  node[above]  {b} (D)
                  (F) edge [bend left]  node[above]  {a} (E)
                  (F) edge   node[above]  {b} (Z);
      \end{tikzpicture}

  \end{itemize}

  \section{自顶向下的语法分析}
  \subsection{确定的自顶向下的语法分析}

  \textbf{开始符号集:}\\
  设$G = (V_T , V_N , P , S)$是上下文无关文法。(产生式左侧只有非终结符)\\
  $\renewcommand{\arraystretch}{0.5}
  FIRST(\alpha) = \{a | \alpha \begin{array}{c} * \\ \Rightarrow \end{array}  a \beta , a \in V_T , \alpha ,\beta\in V^*\}$\\
  则称$\renewcommand{\arraystretch}{0.5}
  FIRST(\alpha)$为$\alpha$的\textbf{开始符号集} 或 \textbf{首符号集}。(可以包含空弧$\epsilon$)\\
  {\color{blue} 也就是求产生式的第一个可能的终结符}

  \spaceline
  \textbf{后跟符号:}\\
  设$G = (V_T , V_N , P , S)$是上下文无关文法,$A\in V_N , S$是开始符号\\
  $\renewcommand{\arraystretch}{0.5}FOLLOW(A) = \{ a | S \begin{array}{c} * \\ \Rightarrow \end{array}
  \mu A\beta\text{且}a\in FIRST(\beta) ,\mu\in V^*_T , \beta\in V^+ \}$(特别的,\#表示输入串的结束符)\\
  {\color{blue} 也就是求产生式第二个可能的终结符,但是只有在有空弧的情况才考虑即($\epsilon \in FIRST(A)$)}

  \spaceline
  \textbf{选择符号集:}\\
  一个产生式的选择符号集合SELECT 。给定上下文无关文法的产生式\\
  $A\to \alpha , A\in V_N , \alpha \in V^*$\\
  若$\renewcommand{\arraystretch}{0.5} \alpha \begin{array}{c} * \\ \cancel{\Rightarrow} \end{array} \epsilon $,\\
  则$SELECT(A \to \alpha) = FIRST(\alpha)$\\
  若$\renewcommand{\arraystretch}{0.5} \alpha \begin{array}{c} * \\ \Rightarrow \end{array} \epsilon $,\\
  则$SELECT(A \to \alpha) = (FIRST(A) - \{\epsilon\})\cup FOLLOW(A)$\\
  {\color{blue} 也就是可选的非终结符,在没空弧的情况就是$FIRST$ , 在有空弧的情况就还要考虑$FOLLOW$(同时去掉空弧)}

  \spaceline
  \textbf{LL(1)文法的充要条件}
  \begin{itemize}
    \item 上下文无关文法
    \item 对于每个非终结符$A$的两个产生式$A \to \alpha ,A \to \beta$,满足
    \[SELECT(A\to a) \cup SELECT(A \to \beta) = \phi\]
    其中,$\alpha , \beta$不同时能$\renewcommand{\arraystretch}{0.5} \begin{array}{c} * \\ \Rightarrow \end{array} \epsilon$\\
    {\color{blue}也就是同一个非终结符的产生式的第一个可能终结符不能相同}
  \end{itemize}

{\color{red}后面根据课本完善...}
\spaceline
\textbf{LL(1)文法的判别:}
充要条件$\to$SELECT集$\to$FIRST+FOLLOW$\to$$\epsilon$

\begin{itemize}
  \item 求FIRST\\
  \begin{itemize}
    \item X1不为空,$FIRST(a)=FIRST(X_1)$
    \item 对于前j个可达空,$FIRST(a) = FIRST(A) + FIRST(X_J) - \{\epsilon\}$
    \item 循环,直到FIRST不变
  \end{itemize}
  \item 求FOLLOW\\
  A = aBC
  \begin{itemize}
    \item B不能达到空,FOLLOW(A) = FOLLOW(A)
    \item 可以达空,FOLLOW(A) = FOLLOW(A) + FIRST(C)
    \item 循环直到FOLOW(A)不再增加
    \item 初始 FOLLOW(S) = {$\#$}
  \end{itemize}
  \item 求SELECT\\
  根据定义进行即可
\end{itemize}

{\color{red}后面补上一个例子}

\subsubsection{非LL(1)文法转LL(1)文法}
不是LL(1)文法:
\begin{itemize}
  \item 消除左递归
  \item 提取左公因子
\end{itemize}

算法实现:......


\subsection{不确定的自顶向下分析}
对于非$LL(1)$文法,就不能确定选择哪个产生式规则,对于待选的产生式,采用回溯搜索,逐条试探的方式进行
其实就是回溯算法啦

注:空弧不需要不断加深,只需要加深一次即可?

\subsection{确定的自顶向下算法}
\begin{itemize}
  \item 递归子程序算法
  \item 预测分析法
\end{itemize}

\end{document}
