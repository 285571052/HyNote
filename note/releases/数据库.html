<!DOCTYPE html>
  <html>
    <head>
      <title>数据库</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({"extensions":["tex2jax.js"],"jax":["input/TeX","output/HTML-CSS"],"messageStyle":"none","tex2jax":{"processEnvironments":false,"processEscapes":true,"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"TeX":{"extensions":["AMSmath.js","AMSsymbols.js","noErrors.js","noUndefined.js"]},"HTML-CSS":{"availableFonts":["TeX"]}});
        </script>
        <script type="text/javascript" async src="file:///C:\Users\qhy28\.atom\packages\markdown-preview-enhanced\node_modules\@shd101wyy\mume\dependencies\mathjax\MathJax.js"></script>
        
      

      
      

      <style> 
      /**
 * prism.js Github theme based on GitHub's theme.
 * @author Sam Clarke
 */
code[class*="language-"],
pre[class*="language-"] {
  color: #333;
  background: none;
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;
  line-height: 1.4;

  -moz-tab-size: 8;
  -o-tab-size: 8;
  tab-size: 8;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

/* Code blocks */
pre[class*="language-"] {
  padding: .8em;
  overflow: auto;
  /* border: 1px solid #ddd; */
  border-radius: 3px;
  /* background: #fff; */
  background: #f5f5f5;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
  white-space: normal;
  background: #f5f5f5;
}

.token.comment,
.token.blockquote {
  color: #969896;
}

.token.cdata {
  color: #183691;
}

.token.doctype,
.token.punctuation,
.token.variable,
.token.macro.property {
  color: #333;
}

.token.operator,
.token.important,
.token.keyword,
.token.rule,
.token.builtin {
  color: #a71d5d;
}

.token.string,
.token.url,
.token.regex,
.token.attr-value {
  color: #183691;
}

.token.property,
.token.number,
.token.boolean,
.token.entity,
.token.atrule,
.token.constant,
.token.symbol,
.token.command,
.token.code {
  color: #0086b3;
}

.token.tag,
.token.selector,
.token.prolog {
  color: #63a35c;
}

.token.function,
.token.namespace,
.token.pseudo-element,
.token.class,
.token.class-name,
.token.pseudo-class,
.token.id,
.token.url-reference .token.variable,
.token.attr-name {
  color: #795da3;
}

.token.entity {
  cursor: help;
}

.token.title,
.token.title .token.punctuation {
  font-weight: bold;
  color: #1d3e81;
}

.token.list {
  color: #ed6a43;
}

.token.inserted {
  background-color: #eaffea;
  color: #55a532;
}

.token.deleted {
  background-color: #ffecec;
  color: #bd2c00;
}

.token.bold {
  font-weight: bold;
}

.token.italic {
  font-style: italic;
}


/* JSON */
.language-json .token.property {
  color: #183691;
}

.language-markup .token.tag .token.punctuation {
  color: #333;
}

/* CSS */
code.language-css,
.language-css .token.function {
  color: #0086b3;
}

/* YAML */
.language-yaml .token.atrule {
  color: #63a35c;
}

code.language-yaml {
  color: #183691;
}

/* Ruby */
.language-ruby .token.function {
  color: #333;
}

/* Markdown */
.language-markdown .token.url {
  color: #795da3;
}

/* Makefile */
.language-makefile .token.symbol {
  color: #795da3;
}

.language-makefile .token.variable {
  color: #183691;
}

.language-makefile .token.builtin {
  color: #0086b3;
}

/* Bash */
.language-bash .token.keyword {
  color: #0086b3;
}html body{font-family:"Helvetica Neue",Helvetica,"Segoe UI",Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;padding:2em;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ul,html body>ol{margin-bottom:16px}html body ul,html body ol{padding-left:2em}html body ul.no-list,html body ol.no-list{padding:0;list-style-type:none}html body ul ul,html body ul ol,html body ol ol,html body ol ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:bold;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:bold}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em !important;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::before,html body code::after{letter-spacing:-0.2em;content:"\00a0"}html body pre>code{padding:0;margin:0;font-size:.85em !important;word-break:normal;white-space:pre;background:transparent;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;font-size:.85em !important;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:before,html body pre tt:before,html body pre code:after,html body pre tt:after{content:normal}html body p,html body blockquote,html body ul,html body ol,html body dl,html body pre{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body pre,html body code{word-wrap:break-word;white-space:pre}}@media screen and (min-width:914px){html body:not([data-presentation-mode]){width:980px;margin:10px auto}}@media screen and (max-width:400px){html body:not([data-presentation-mode]){font-size:14px;margin:0 auto;padding:15px}}html body .pagebreak,html body .newpage{page-break-before:always}html body pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}html body pre.line-numbers>code{position:relative}html body pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}html body pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}html body pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}html body .mathjax-exps .MathJax_Display{text-align:center !important}html body:not([for="preview"]) .code-chunk .btn-group{display:none}html body:not([for="preview"]) .code-chunk .status{display:none}html body:not([for="preview"]) .code-chunk .output-div{margin-bottom:16px} 
       
      </style>
    </head>
    <body class="mume   ">
    <ul>
<li><a href="#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E6%A0%87">学习目标</a></li>
<li><a href="#%E8%80%83%E6%A0%B8%E6%96%B9%E5%BC%8F">考核方式</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E6%B0%B4%E5%B9%B3">如何提高水平</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%88%86%E7%B1%BB">数据库的分类</a>
<ul>
<li><a href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%A8%A1%E5%9E%8B">关系型模型</a></li>
<li><a href="#%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%80%A7">关系型数据的约束性</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84">数据库系统的结构</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84">数据库的模式结构</a></li>
<li><a href="#%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0">关系代数</a>
<ul>
<li><a href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97">关系运算</a>
<ul>
<li><a href="#%E9%80%89%E6%8B%A9">选择</a></li>
<li><a href="#%E6%8A%95%E5%BD%B1">投影</a></li>
<li><a href="#%E8%BF%9E%E6%8E%A5">连接</a></li>
<li><a href="#%E7%AD%89%E5%80%BC%E8%BF%9E%E6%8E%A5">等值连接</a></li>
<li><a href="#%E8%87%AA%E7%84%B6%E8%BF%9E%E6%8E%A5">自然连接</a></li>
<li><a href="#%E5%A4%96%E8%BF%9E%E6%8E%A5">外连接</a></li>
</ul>
</li>
<li><a href="#%E9%99%A4">除</a></li>
</ul>
</li>
<li><a href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80-sql%E8%AF%AD%E8%A8%80">结构化的查询语言 SQL语言</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89">数据定义</a>
<ul>
<li><a href="#%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%A0%E9%99%A4">模式的定义和删除</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%BC%8F">定义模式</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E6%A8%A1%E5%BC%8F">删除模式</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89-%E5%88%A0%E9%99%A4-%E4%BF%AE%E6%94%B9">基本表的定义、删除、修改</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E5%9F%BA%E6%9C%AC%E8%A1%A8">定义基本表</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>
</ul>
</li>
<li><a href="#%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A1%A8">模式与表</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E8%A1%A8">修改表</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E5%9F%BA%E6%9C%AC%E8%A1%A8">删除基本表</a></li>
</ul>
</li>
<li><a href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E5%88%A0%E9%99%A4">索引的建立与删除</a>
<ul>
<li><a href="#%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95">建立索引</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E7%B4%A2%E5%BC%95">修改索引</a></li>
<li><a href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95">删除索引</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2">数据查询</a>
<ul>
<li><a href="#%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2">单表查询</a>
<ul>
<li><a href="#%E9%80%89%E6%8B%A9%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%88%97">选择表中的若干列</a>
<ul>
<li><a href="#%E6%9F%A5%E8%AF%A2%E6%8C%87%E5%AE%9A%E5%88%97">查询指定列</a></li>
<li><a href="#%E6%9F%A5%E8%AF%A2%E5%85%A8%E9%83%A8%E5%88%97">查询全部列</a></li>
<li><a href="#%E6%9F%A5%E8%AF%A2%E7%BB%8F%E8%BF%87%E8%AE%A1%E7%AE%97%E7%9A%84%E5%80%BC">查询经过计算的值</a></li>
</ul>
</li>
<li><a href="#%E9%80%89%E6%8B%A9%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8B%A5%E5%B9%B2%E5%85%83%E7%BB%84">选择表中的若干元组</a>
<ul>
<li><a href="#%E6%B6%88%E9%99%A4%E5%8F%96%E5%80%BC%E9%87%8D%E5%A4%8D%E7%9A%84%E8%A1%8C">消除取值重复的行</a></li>
<li><a href="#%E6%9F%A5%E8%AF%A2%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%85%83%E7%BB%84">查询满足条件的元组</a>
<ul>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D">字符串匹配</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0">聚集函数</a></li>
<li><a href="#order-by-%E5%AD%90%E5%8F%A5">ORDER BY 子句</a></li>
<li><a href="#group-by-%E5%AD%90%E5%8F%A5">GROUP BY 子句</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2">连接查询</a>
<ul>
<li><a href="#%E8%87%AA%E8%BA%AB%E8%BF%9E%E6%8E%A5">自身连接</a></li>
<li><a href="#%E5%A4%96%E8%BF%9E%E6%8E%A5-1">外连接</a></li>
<li><a href="#%E5%A4%9A%E8%A1%A8%E8%BF%9E%E6%8E%A5">多表连接</a></li>
</ul>
</li>
<li><a href="#%E5%B5%8C%E5%A5%97%E6%9F%A5%E8%AF%A2">嵌套查询</a>
<ul>
<li><a href="#%E4%B8%8D%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2">不相关子查询</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E5%AD%90%E6%9F%A5%E8%AF%A2">相关子查询</a></li>
<li><a href="#any-%E6%88%96-some-all-%E8%B0%93%E8%AF%8D%E4%B8%8E%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0in%E8%B0%93%E8%AF%8D%E7%9A%84%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB">ANY (或 SOME) 、 ALL 谓词与聚集函数,IN谓词的等价关系</a></li>
<li><a href="#%E5%B8%A6%E6%9C%89-exists-%E8%B0%93%E8%AF%8D%E7%9A%84%E5%AD%90%E6%9F%A5%E8%AF%A2">带有 <code>EXISTS</code> 谓词的子查询</a></li>
</ul>
</li>
<li><a href="#%E9%9B%86%E5%90%88%E6%9F%A5%E8%AF%A2">集合查询</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8E%E6%B4%BE%E7%94%9F%E8%A1%A8%E7%9A%84%E6%9F%A5%E8%AF%A2">基于派生表的查询</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0">数据更新</a>
<ul>
<li><a href="#%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE">插入数据</a>
<ul>
<li><a href="#%E6%8F%92%E5%85%A5%E5%85%83%E7%BB%84">插入元组</a></li>
<li><a href="#%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE">修改数据</a></li>
</ul>
</li>
<li><a href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE">删除数据</a></li>
</ul>
</li>
<li><a href="#%E7%A9%BA%E5%80%BC%E5%A4%84%E7%90%86">空值处理</a></li>
<li><a href="#%E8%A7%86%E5%9B%BE">视图</a></li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96">查询优化</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%8A%80%E6%9C%AF">数据库恢复技术</a>
<ul>
<li><a href="#%E6%95%85%E9%9A%9C%E7%9A%84%E7%A7%8D%E7%B1%BB">故障的种类</a>
<ul>
<li><a href="#%E4%BA%8B%E5%8A%A1%E5%86%85%E9%83%A8%E6%95%85%E9%9A%9C">事务内部故障</a></li>
<li><a href="#%E7%B3%BB%E7%BB%9F%E6%95%85%E9%9A%9C">系统故障</a></li>
<li><a href="#%E4%BB%8B%E8%B4%A8%E6%95%85%E9%9A%9C">介质故障</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92">计算机病毒</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%81%A2%E5%A4%8D%E6%93%8D%E4%BD%9C">数据库恢复操作</a></li>
</ul>
</li>
</ul>
<h1 class="mume-header" id="&#x5B66;&#x4E60;&#x76EE;&#x6807;">学习目标</h1>

<p><img src="assets/%E6%95%B0%E6%8D%AE%E5%BA%93-a04c5.png" alt="1"></p>
<h1 class="mume-header" id="&#x8003;&#x6838;&#x65B9;&#x5F0F;">考核方式</h1>

<p><img src="assets/%E6%95%B0%E6%8D%AE%E5%BA%93-cc73d.png" alt="2"></p>
<h1 class="mume-header" id="&#x5982;&#x4F55;&#x63D0;&#x9AD8;&#x6C34;&#x5E73;">如何提高水平</h1>

<p><img src="assets/%E6%95%B0%E6%8D%AE%E5%BA%93-90249.png" alt="3"></p>
<h1 class="mume-header" id="&#x6570;&#x636E;&#x5E93;">数据库</h1>

<ol>
<li>数据</li>
<li>数据库<br>
就是数据的集合</li>
<li>数据库管理系统<br>
支持一下功能
<ol>
<li>数据的定义</li>
<li>数据的组织，存储，管理</li>
<li>数据的操纵</li>
<li>数据的建立和维护</li>
<li>数据的事务管理和运行管理</li>
<li>其他</li>
</ol>
</li>
</ol>
<p>人工管理的缺点：</p>
<ol>
<li>不保存</li>
<li>直接通过应用程序管理数据</li>
<li>不共享</li>
<li>不独立</li>
</ol>
<p>文件系统：</p>
<ol>
<li>长期保存<br>
2。 由文件系统管理</li>
<li>冗余度大</li>
<li>独立性差</li>
</ol>
<p>数据库：</p>
<ol>
<li>数据结构化</li>
<li>共享性高， 冗余度低</li>
<li>独立性强</li>
<li>数据由数据库管理系统统一管理和控制</li>
</ol>
<h1 class="mume-header" id="&#x6570;&#x636E;&#x5E93;&#x7684;&#x5206;&#x7C7B;">数据库的分类</h1>

<p>非关系型模型:层次模型，网状模型，由于这两种模型难以表达数据，因此没有普及，也因此不讲</p>
<p>关系型模型:比前面两个模型更加简化的模型，又叫作 表，二维表，是当前(2017-3)主流的数据库模型</p>
<h2 class="mume-header" id="&#x5173;&#x7CFB;&#x578B;&#x6A21;&#x578B;">关系型模型</h2>

<p>逻辑上，所有的数据由一个个表组成，但物理上还是基于文件系统的。</p>
<p><s>一个图</s></p>
<p>每一个实体由一行组成，每一行又叫做元组，或者记录<br>
域:属性的取值范围<br>
度不能太大</p>
<p>随着日志的规模越来越大，如果数据都放在一个表中，那么速度会越来越慢</p>
<p>问:主码和码的区别?<br>
码:由实体间相互区分的属性构成，即码的值不可以重复，但是码可以有多个。也就是说只要属性值不重复的属性都可以称为码（名字如果没有重复的话，也可以是码）<br>
主码:主码只能有一个，但是不是指一个属性，可以由多个属性联合表示，但是它必须可以唯一确定一个元组。</p>
<p>问:关系型数据无法处理表中嵌套表的表示，那这个情况要怎么表达？<br>
上面的意思是，一个表中的属性不可以再次区分，（也就是属性不能是表），这个时候可以把表嵌套表的数据拆分成多个表来表示（也就是嵌套的表再次拆分出来）。</p>
<h2 class="mume-header" id="&#x5173;&#x7CFB;&#x578B;&#x6570;&#x636E;&#x7684;&#x7EA6;&#x675F;&#x6027;">关系型数据的约束性</h2>

<ol>
<li>实体完整性</li>
<li>参照完整性</li>
<li>用户定义的完整性</li>
</ol>
<h1 class="mume-header" id="&#x6570;&#x636E;&#x5E93;&#x7CFB;&#x7EDF;&#x7684;&#x7ED3;&#x6784;">数据库系统的结构</h1>

<ol start="0">
<li>
<p>单用户数据系统</p>
</li>
<li>
<p>主从式数据库系统</p>
</li>
<li>
<p>分布式数据库系统<br>
主要是数据的同步和处理</p>
</li>
<li>
<p>C/S结构数据库<br>
比如，360的病毒库，手机app</p>
</li>
<li>
<p>B/S 服务器结构<br>
能简化应用操作的复杂性</p>
</li>
<li>
<p>嵌入式数据库<br>
数据库的规模小</p>
</li>
</ol>
<h1 class="mume-header" id="&#x6570;&#x636E;&#x5E93;&#x7684;&#x6A21;&#x5F0F;&#x7ED3;&#x6784;">数据库的模式结构</h1>

<p>三级模式结构<br>
外模式:通过视图/应用该程序 来访问数据，对用户来说，这个是不透明的（也就是用户只关心拿到的数据，而不关心数据内部的结构）</p>
<h1 class="mume-header" id="&#x5173;&#x7CFB;&#x4EE3;&#x6570;">关系代数</h1>

<p>关系代数是一种抽象的查询语言，它同对关系的运算来表达查询。<br>
关系袋鼠的运算按运算符的不同分为两种：</p>
<ol>
<li>传统的集合运算<br>
主要包括，并，交，差，笛卡儿积</li>
<li>专门的关系运算</li>
</ol>
<table>
<thead>
<tr>
<th>集合运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="mathjax-exps">$&#x5C;cup$</span></td>
<td>并</td>
</tr>
<tr>
<td><span class="mathjax-exps">$&#x5C;cap$</span></td>
<td>交</td>
</tr>
<tr>
<td><span class="mathjax-exps">$-$</span></td>
<td>差</td>
</tr>
<tr>
<td><span class="mathjax-exps">$&#x5C;times$</span></td>
<td>笛卡儿积</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>关系运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="mathjax-exps">$&#x5C;sigma$</span></td>
<td>选择</td>
</tr>
<tr>
<td><span class="mathjax-exps">$&#x5C;Pi$</span></td>
<td>投影</td>
</tr>
<tr>
<td><span class="mathjax-exps">$&#x5C;Join$</span></td>
<td>连接</td>
</tr>
<tr>
<td><span class="mathjax-exps">$&#x5C;div$</span></td>
<td>除</td>
</tr>
</tbody>
</table>
<h2 class="mume-header" id="&#x5173;&#x7CFB;&#x8FD0;&#x7B97;">关系运算</h2>

<h3 class="mume-header" id="&#x9009;&#x62E9;">选择</h3>

<p>选择：在关系R中选择满足给定条件F的诸元组（从行中选择行）<br>
<span class="mathjax-exps">$&#x5C;sigma_F(R)$</span></p>
<h3 class="mume-header" id="&#x6295;&#x5F71;">投影</h3>

<p>投影：从关系R中选择若干属性组成新的关系（即从列中抽取列出来组成一个新的表）<br>
注意：投影的结果是会去重复的。<br>
比如，投影性别，结果是{男，女}，而不是{男，男，女，女}<br>
<span class="mathjax-exps">$&#x5C;Pi_A(R)$</span></p>
<h3 class="mume-header" id="&#x8FDE;&#x63A5;">连接</h3>

<p>从两个关系的笛卡尔积中选择属性间满足一定关系的的元组。<br>
<span class="mathjax-exps">$&#x5C;begin{matrix}R &#x5C;Join S &#x5C;&#x5C;&#x5C;scriptsize{A  &#x5C;Theta B}&#x5C;end{matrix}$</span></p>
<h3 class="mume-header" id="&#x7B49;&#x503C;&#x8FDE;&#x63A5;">等值连接</h3>

<p><span class="mathjax-exps">$&#x5C;begin{matrix}R &#x5C;Join S &#x5C;&#x5C;&#x5C;scriptsize{A  = B}&#x5C;end{matrix}$</span><br>
表示从关系R和S的笛卡儿积中，选择A和B属性值相等的i那些元组。（A是R的属性，B是S的属性）</p>
<h3 class="mume-header" id="&#x81EA;&#x7136;&#x8FDE;&#x63A5;">自然连接</h3>

<p>自然连接是特殊的等值连接，它要求两个属性名必须相同。<br>
取 等值连接的两个属性名相同的列出来 组成一个新的表。并且两个同名的属性，只保留一个下来。</p>
<h3 class="mume-header" id="&#x5916;&#x8FDE;&#x63A5;">外连接</h3>

<p>在自然连接的时候，不存在属性值相等的元素，那么就会被丢弃。<br>
被丢弃的元组称为悬浮元组。<br>
如果保留这些悬浮元组。那么就称为外连接。<br>
如果只保留左边关系R中的悬浮元组，称为左外连接<br>
如果只保留右边关系S中的悬浮元组，称为右外连接</p>
<h2 class="mume-header" id="&#x9664;">除</h2>

<p><span class="mathjax-exps">$R &#x5C;div S = T$</span><br>
结果T包含了在R但不在S中的属性及值，且T的元组与S的元组的所以组合都在R中。</p>
<h1 class="mume-header" id="&#x7ED3;&#x6784;&#x5316;&#x7684;&#x67E5;&#x8BE2;&#x8BED;&#x8A00;-sql&#x8BED;&#x8A00;">结构化的查询语言 SQL语言</h1>

<p>结果来自同一个表，但是不是一次遍历得到的时候，应该使用更名运算，逻辑上把一个表看作两个表，理解成内容相同的两个表经过一次遍历得到结果（之所以是要更名，就是为了区别这两个逻辑上的表，否则表达式就有歧义了）</p>
<p>基本表是本身独立存在的表，在关系数据库管理系统中一个关系就对应一个基本表。一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。</p>
<h2 class="mume-header" id="&#x6570;&#x636E;&#x5B9A;&#x4E49;">数据定义</h2>

<p>一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表，试图，索引等数据对象</p>
<h3 class="mume-header" id="&#x6A21;&#x5F0F;&#x7684;&#x5B9A;&#x4E49;&#x548C;&#x5220;&#x9664;">模式的定义和删除</h3>

<h4 class="mume-header" id="&#x5B9A;&#x4E49;&#x6A21;&#x5F0F;">定义模式</h4>

<pre class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">SCHEMA</span> <span class="token operator">&lt;</span>模式名<span class="token operator">></span> <span class="token keyword">AUTHORIZATION</span> <span class="token operator">&lt;</span>用户名<span class="token operator">></span><span class="token punctuation">;</span>
</pre>
<p>如果没有指定 <code>&lt;模式名&gt;</code>，那么 <code>&lt;模式名&gt;</code> 就隐含为 <code>&lt;用户名&gt;</code></p>
<p>例子：为用户 <code>WANG</code> 定义一个学生-课程模式 S-T</p>
<pre class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">SCHEMA</span> <span class="token string">"S-T"</span> <span class="token keyword">AUTHORIZATION</span> WANG
</pre>
<h4 class="mume-header" id="&#x5220;&#x9664;&#x6A21;&#x5F0F;">删除模式</h4>

<pre class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">SCHEMA</span> <span class="token operator">&lt;</span>模式名<span class="token operator">></span><span class="token operator">&lt;</span><span class="token keyword">CASCADE</span><span class="token operator">|</span><span class="token keyword">RESTRICT</span><span class="token operator">></span>
</pre>
<p><code>CASCADE</code>:级联，表示在删除模式的同时，把该模式中所有的数据库对象都删除。<br>
<code>RESTRICT</code>:限制，表示如果该模式中已经定义了下属的数据库对象，则拒绝该删除语句的执行。</p>
<h3 class="mume-header" id="&#x57FA;&#x672C;&#x8868;&#x7684;&#x5B9A;&#x4E49;-&#x5220;&#x9664;-&#x4FEE;&#x6539;">基本表的定义、删除、修改</h3>

<h4 class="mume-header" id="&#x5B9A;&#x4E49;&#x57FA;&#x672C;&#x8868;">定义基本表</h4>

<pre class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token operator">&lt;</span>数据库类型<span class="token operator">></span><span class="token punctuation">[</span>列级完整性约束条件<span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token operator">&lt;</span>数据库类型<span class="token operator">></span><span class="token punctuation">[</span>列级完整性约束条件<span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>表级完整性约束条件<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
<p>例子:建立一个&quot;学生&quot;表 Student</p>
<pre class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Student
  <span class="token punctuation">(</span>Sno CHAR<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span> PRIMARYKEY<span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">/* `Sno` 是主码*/</span>
  Sname CHAR<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">UNIQUE</span><span class="token punctuation">,</span>
      <span class="token comment" spellcheck="true">/*取值唯一的列*/</span>
  Ssex CHAR<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  Sage <span class="token keyword">SMALLINT</span><span class="token punctuation">,</span>
  Sdept CHAR<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
<p>约束条件:<br>
<code>UNIQUE</code>：取值唯一的列名；<br>
<code>PRIMARY KEY</code>：主关键字（主码）列名；<br>
<code>NOT NULL</code>：列值不能为空值；<br>
<code>FOREIGN KEY</code>：外部码列名；<br>
<code>REFERENCES</code>：引用的外部码的表名和列名<br>
<code>CHECK</code>:满足某个条件</p>
<p><code>UNIQUE</code>,<code>PRIMARY KEY</code>:</p>
<pre class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span>   dept<span class="token punctuation">(</span>
	deptno 	  char<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	dname	  <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	loc	  <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token keyword">CONSTRAINT</span> dept_dname_uk <span class="token keyword">UNIQUE</span> <span class="token punctuation">(</span>dname<span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token keyword">CONSTRAINT</span> dept_deptno_pk <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span><span class="token punctuation">(</span>deptno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
<p><code>FOREIGN KEY</code>:既可在列级定义也可以在表级定义</p>
<pre class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> emp<span class="token punctuation">(</span>
	empno 	char<span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  	ename	<span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  	job	<span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  	mgr	<span class="token keyword">NUMERIC</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  	hiredate	<span class="token keyword">DATETIME</span><span class="token punctuation">,</span>
  	sal	<span class="token keyword">NUMERIC</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
   	comm	<span class="token keyword">NUMERIC</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">--佣金</span>
  	deptno	<span class="token keyword">NUMERIC</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
	<span class="token keyword">CONSTRAINT</span> emp_deptno_fk <span class="token keyword">FOREIGN</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span>deptno<span class="token punctuation">)</span>
			<span class="token keyword">REFERENCES</span> dept <span class="token punctuation">(</span>deptno<span class="token punctuation">)</span><span class="token punctuation">)</span>
</pre>
<p><code>CHECK</code>:</p>
<pre class="language-sql"><span class="token keyword">CONSTRAINT</span> emp_deptno_ck  
            <span class="token keyword">CHECK</span> <span class="token punctuation">(</span>DEPTNO <span class="token operator">BETWEEN</span> <span class="token number">10</span> <span class="token operator">AND</span> <span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
</pre>
<h5 class="mume-header" id="&#x6570;&#x636E;&#x7C7B;&#x578B;">数据类型</h5>

<table>
<thead>
<tr>
<th>数据类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>CHAR(n),CHARACTER(n)</td>
<td>长度为n的定长字符串</td>
</tr>
<tr>
<td>VARCHAR(n),CHARACTERVARYING(n)</td>
<td>最大长度为n的变长字符串</td>
</tr>
<tr>
<td>CLOB</td>
<td>字符串大对象</td>
</tr>
<tr>
<td>BLOB</td>
<td>二进制大对象</td>
</tr>
<tr>
<td>INT,INTEGER</td>
<td>长整数(4字节)</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>短整数(2字节)</td>
</tr>
<tr>
<td>BIGINT</td>
<td>大整数(8字节)</td>
</tr>
<tr>
<td>NUMERIC(p,d)</td>
<td>定点数,由p位数字(不包括符号,小数点)组成,小数点后面有d位数字</td>
</tr>
<tr>
<td>DECIMAL(p,d),DEC(p,d)</td>
<td>同NUMERIC</td>
</tr>
<tr>
<td>REAL</td>
<td>取决于机器精度的单精度浮点数</td>
</tr>
<tr>
<td>DOUBLE PRECISION</td>
<td>取决于机器精度的双精度浮点数</td>
</tr>
<tr>
<td>FLOAT(n)</td>
<td>可选择精度的浮点数,精度至少为n位数字</td>
</tr>
<tr>
<td>BOOLEAN</td>
<td>逻辑布尔量</td>
</tr>
<tr>
<td>DATE</td>
<td>日期,包含年、月、日,格式为YYYY-MM-DD</td>
</tr>
<tr>
<td>TIME</td>
<td>时间,包含一日的时、分、秒,格式为HH:MM:SS</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>时间戳类型</td>
</tr>
<tr>
<td>INTERVAL</td>
<td>时间间隔类型</td>
</tr>
</tbody>
</table>
<h4 class="mume-header" id="&#x6A21;&#x5F0F;&#x4E0E;&#x8868;">模式与表</h4>

<p>每一个基本表都属于某个模式,一个模式包含多个基本表。<br>
那怎么关联这个模式和表?有三种方法。</p>
<ol>
<li>
<p>在表名明显地给出模式名</p>
<pre class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token string">"S-T"</span><span class="token punctuation">.</span>Student<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//Student 所属的模式是 S-T</span>
</pre>
</li>
<li>
<p>在创建模式的语句中同时创建表<br>
也就是创建模式的语句后面,紧跟创建表的语句。</p>
</li>
<li>
<p>设置所属的模式,这样在创建表时表名不必给出模式名</p>
<pre class="language-sql"><span class="token keyword">SET</span> search <span class="token keyword">TO</span> <span class="token string">"S-T"</span><span class="token punctuation">,</span><span class="token keyword">PUBLIC</span><span class="token punctuation">;</span>
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> Student<span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
</li>
</ol>
<h4 class="mume-header" id="&#x4FEE;&#x6539;&#x8868;">修改表</h4>

<p>SQL语言用<code>ALTER TABLE</code> 语句来修改基本表。</p>
<pre class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span>
<span class="token punctuation">[</span><span class="token keyword">ADD</span> <span class="token punctuation">[</span><span class="token keyword">COLUMN</span><span class="token punctuation">]</span>  <span class="token operator">&lt;</span>新列名<span class="token operator">></span><span class="token operator">&lt;</span>数据类型<span class="token operator">></span> <span class="token punctuation">[</span>完整性约束<span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token keyword">ADD</span> <span class="token operator">&lt;</span>表级完整性约束<span class="token operator">></span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token keyword">DROP</span> <span class="token punctuation">[</span><span class="token keyword">COLUMN</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">CASCADE</span><span class="token operator">|</span><span class="token keyword">RESTRICT</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token comment" spellcheck="true">/*CASCADE:自动删除引动该列的对象,RESTRICT:如果已经有引用,则拒绝删除*/</span>
<span class="token punctuation">[</span><span class="token keyword">DROP</span> <span class="token keyword">CONSTRAINT</span><span class="token operator">&lt;</span>完整性约束<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">RESTRICT</span><span class="token operator">|</span><span class="token keyword">CASCADE</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token comment" spellcheck="true">/*CONSTRAINT 用于删除指定的完整性约束条件*/</span>
<span class="token punctuation">[</span><span class="token keyword">ALTER</span> <span class="token keyword">COLUMN</span> <span class="token operator">&lt;</span>列名<span class="token operator">></span><span class="token operator">&lt;</span>数据类型<span class="token operator">></span><span class="token punctuation">]</span>
    <span class="token comment" spellcheck="true">/*用于修改原有的列定义*/</span>
</pre>
<h4 class="mume-header" id="&#x5220;&#x9664;&#x57FA;&#x672C;&#x8868;">删除基本表</h4>

<pre class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">RESTRICT</span><span class="token operator">|</span><span class="token keyword">CASCADE</span><span class="token punctuation">]</span>
    <span class="token comment" spellcheck="true">/*默认是 RESTRICT*/</span>
</pre>
<h3 class="mume-header" id="&#x7D22;&#x5F15;&#x7684;&#x5EFA;&#x7ACB;&#x4E0E;&#x5220;&#x9664;">索引的建立与删除</h3>

<p>一般说来,建立与删除索引由数据库管理员或表的 <strong>属主</strong>( <strong>owner</strong> ),即建立表的人,负责完成。<br>
用户不必也不能显示地选择索引。<br>
索引是关系型数据库管理系统的内部实现技术,属于内模式的范畴。</p>
<p>可以动态地定义索引，即可以随时建立和删除索引；</p>
<p>不允许用户在数据操作中引用索引。索引如何使用完全由系统决定，这支持了数据的物理独立性；</p>
<p>一个表上可建多个索引。索引可以提高查询效率，但索引过多耗费空间，且降低了插入、删除、更新的效率；</p>
<p>建立索引的两个主要目的：加快查询速度、保证行的唯一性。</p>
<ul>
<li>下列情况，需要建立索引
<ul>
<li>列取值范围较大时</li>
<li>在WHERE或连接条件中频繁使用的列</li>
<li>列包含大量的非空值</li>
<li>查询少于2-4%行的大表</li>
</ul>
</li>
<li>下列条件不要创建索引:
<ul>
<li>小表</li>
<li>列并不频繁用在查询条件中</li>
<li>查询超过2–4%的行</li>
<li>表频繁被更新（如操作日志表、事件表）</li>
</ul>
</li>
</ul>
<h4 class="mume-header" id="&#x5EFA;&#x7ACB;&#x7D22;&#x5F15;">建立索引</h4>

<pre class="language-sql"><span class="token keyword">CREATE</span> <span class="token punctuation">[</span><span class="token keyword">UNIQUE</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>CLUSTER<span class="token punctuation">]</span> <span class="token keyword">INDEX</span> <span class="token operator">&lt;</span>索引名<span class="token operator">></span>
<span class="token keyword">ON</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span><span class="token punctuation">(</span><span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>次序<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>列名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>次序<span class="token operator">></span><span class="token punctuation">]</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/* 次序由两种选择:ASC:升序,DESC:降序
     * CLUSTER 表示要建立的索引是聚簇索引
     * UNIQUE 表明此索引的每一个索引值只对应唯一的数据记录
     */</span>
</pre>
<h4 class="mume-header" id="&#x4FEE;&#x6539;&#x7D22;&#x5F15;">修改索引</h4>

<pre class="language-">ALTER INDEX &lt;&#x65E7;&#x7D22;&#x5F15;&#x540D;&gt; RENAME TO &lt;&#x65B0;&#x7D22;&#x5F15;&#x540D;&gt;
</pre>
<h4 class="mume-header" id="&#x5220;&#x9664;&#x7D22;&#x5F15;">删除索引</h4>

<pre class="language-">DROP INDEX &lt;&#x7D22;&#x5F15;&#x540D;&gt;
</pre>
<h2 class="mume-header" id="&#x6570;&#x636E;&#x67E5;&#x8BE2;">数据查询</h2>

<pre class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">[</span><span class="token keyword">ALL</span><span class="token operator">|</span>DISTINCE<span class="token punctuation">]</span> <span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>目标列表达式<span class="token operator">></span><span class="token punctuation">]</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token operator">*</span>
<span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名或视图名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>表名或视图名<span class="token operator">></span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token keyword">SELECT</span> 语句<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">AS</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>别名<span class="token operator">></span>
    <span class="token comment" spellcheck="true">/*别名的命名方式:在下一个列之前(逗号之前)加上 "[空格]别名"*/</span>
<span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span>
    <span class="token comment" spellcheck="true">/*根据WHERE子句的条件表达式从FROM子句指定的基本表、视图或派生表中找出满足条件的元组,再按SELECT 子句的目标列表达式选出元组中的属性形成结果表*/</span>
<span class="token punctuation">[</span>GROUD <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token number">1</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">HAVING</span> <span class="token operator">&lt;</span>条件表达式<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">]</span>
    <span class="token comment" spellcheck="true">/* 将结果按&lt;列名1>的值进行分组,该属性列值相等的元组为一个组。通常会再每组中作用聚集函数
     * HAVING 短语,只有满足制定条件的组才予以输出。 */</span>
<span class="token punctuation">[</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token number">2</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</pre>
<h3 class="mume-header" id="&#x5355;&#x8868;&#x67E5;&#x8BE2;">单表查询</h3>

<h4 class="mume-header" id="&#x9009;&#x62E9;&#x8868;&#x4E2D;&#x7684;&#x82E5;&#x5E72;&#x5217;">选择表中的若干列</h4>

<p>也就是决定输出哪些列(属性)</p>
<h5 class="mume-header" id="&#x67E5;&#x8BE2;&#x6307;&#x5B9A;&#x5217;">查询指定列</h5>

<p>查询全体学生的学号与姓名</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span>Sname
<span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
</pre>
<h5 class="mume-header" id="&#x67E5;&#x8BE2;&#x5168;&#x90E8;&#x5217;">查询全部列</h5>

<p>即以 <code>*</code> 号省略列名的书写<br>
查询全体学生的详细信息</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Student<span class="token punctuation">;</span>
</pre>
<h5 class="mume-header" id="&#x67E5;&#x8BE2;&#x7ECF;&#x8FC7;&#x8BA1;&#x7B97;&#x7684;&#x503C;">查询经过计算的值</h5>

<p>查询全体学生的姓名及其出生年份(只知道学生的年龄)</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Sname<span class="token punctuation">,</span><span class="token number">2014</span><span class="token operator">-</span>Sage
<span class="token keyword">FROM</span> Student
</pre>
<p>目标列不仅可以是算数表达式,也可以是字符串常量、常数等。<br>
如果是字符串常亮则输出字符串。</p>
<h4 class="mume-header" id="&#x9009;&#x62E9;&#x8868;&#x4E2D;&#x7684;&#x82E5;&#x5E72;&#x5143;&#x7EC4;">选择表中的若干元组</h4>

<p>也就是决定输出哪些行(元组)</p>
<h5 class="mume-header" id="&#x6D88;&#x9664;&#x53D6;&#x503C;&#x91CD;&#x590D;&#x7684;&#x884C;">消除取值重复的行</h5>

<pre class="language-sql"><span class="token keyword">SELECT</span> DISTINCE <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</pre>
<h5 class="mume-header" id="&#x67E5;&#x8BE2;&#x6EE1;&#x8DB3;&#x6761;&#x4EF6;&#x7684;&#x5143;&#x7EC4;">查询满足条件的元组</h5>

<p>通过指定<code>WHERE</code>子句实现</p>
<p>常用的查询条件:</p>
<table>
<thead>
<tr>
<th>查询条件</th>
<th>谓词</th>
</tr>
</thead>
<tbody>
<tr>
<td>比较</td>
<td>=,&gt;,&lt;,&gt;=,&lt;=,!=,&lt;&gt;,!&gt;,!&lt;; NOT+上述比较运算符</td>
</tr>
<tr>
<td>确定范围</td>
<td>BETWEEN AND,NOT BETWEEN AND</td>
</tr>
<tr>
<td>确定集合</td>
<td>IN, NOT ,IN</td>
</tr>
<tr>
<td>字符匹配</td>
<td>LIKE,NOT LIKE</td>
</tr>
<tr>
<td>空值</td>
<td>IS NULL,IS NOT NULL</td>
</tr>
<tr>
<td>多重条件(逻辑运算)</td>
<td>AND ,OR,NOT</td>
</tr>
</tbody>
</table>
<p><code>&lt;&gt;</code>也是不等于的意思。</p>
<p>确定集合:查询计算机系(CS),数学系(MA)的学生的姓名和性别。</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Sname<span class="token punctuation">,</span>Ssex
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sdept <span class="token operator">IN</span> <span class="token punctuation">(</span><span class="token string">'CS'</span><span class="token punctuation">,</span><span class="token string">'MA'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
<h6 class="mume-header" id="&#x5B57;&#x7B26;&#x4E32;&#x5339;&#x914D;">字符串匹配</h6>

<pre class="language-sql"><span class="token punctuation">[</span><span class="token operator">NOT</span><span class="token punctuation">]</span> <span class="token operator">LIKE</span> <span class="token string">'&lt;匹配串>'</span> <span class="token punctuation">[</span><span class="token keyword">ESCAPE</span> <span class="token string">'&lt;换码字符>'</span><span class="token punctuation">]</span>
</pre>
<p>字符匹配的通配符:<br>
<code>%</code>:代表任意长度(长度可以为0)的字符串。<br>
<code>_</code>:代表任意单个字符。<br>
例子:查询学号为 201215121 的学生的详细情况</p>
<pre class="language-sql">ELSECT <span class="token operator">*</span>
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> Sno <span class="token operator">LIKE</span> <span class="token string">'201215121'</span><span class="token punctuation">;</span>
</pre>
<p>注意:</p>
<ol>
<li>
<p>这里是<code>WHERE</code>语句等价于<code>WHERE Sno = '201215121'</code> ,<br>
因为后面没有<code>%</code>,所以不是查询所有 以 <code>201215121</code> 开头的学生。</p>
</li>
<li>
<p>数据库字符集为 ASCII 时,一个汉字需要二个<code>_</code>;当字符集为 GBK 时只需要一个。</p>
</li>
</ol>
<p>转义字符(换码字符):当需要输入 <code>_</code> 或者 <code>%</code> 这些统配字符的时候,需要转移,转移的标记不是固定的,需要自己指出<br>
例子:查询 DB_Design 课程的课程号和学分</p>
<pre class="language-">SELECT Cno,Credit
FROM Course
WHERE Cname LIKE &apos;DB\_Design&apos; ESCAPE &apos;\&apos;
</pre>
<p>这里的<code>\</code>表示换码字符,这样紧跟在<code>\</code>后面的字符<code>_</code>就不具备通配符含义,同事如果要输出<code>\</code>,那么就需要输入<code>\\</code></p>
<h4 class="mume-header" id="&#x805A;&#x96C6;&#x51FD;&#x6570;">聚集函数</h4>

<p>常见的聚集函数:</p>
<table>
<thead>
<tr>
<th><code>COUNT(*)</code></th>
<th>统计元组的个数</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>COUNT([DISTINT\ALL] &lt;列名&gt;)</code></td>
<td>统计一列</td>
</tr>
<tr>
<td><code>SUM( [DISTINT\ALL] &lt;列名&gt; )</code></td>
<td>统计一列值得综合(此列必须是数值型)</td>
</tr>
<tr>
<td><code>AVG( [DISTINT\ALL] &lt;列名&gt; )</code></td>
<td>统计一列值的平均值(此列必须是数值型)</td>
</tr>
<tr>
<td><code>MAX( [DISTINT\ALL] &lt;列名&gt; )</code></td>
<td>求一列值中的最大值</td>
</tr>
<tr>
<td><code>MIN( [DISTINT\ALL] &lt;列名&gt; )</code></td>
<td>求一列值中的最小值</td>
</tr>
</tbody>
</table>
<p>如果指定了 <code>DISTINT</code> 短语,则表示在计算时要取消指定列中的重复值。<br>
如果不指定 <code>DISTINT</code> 或者指定 <code>ALL</code> 短语( <code>ALL</code> 为默认值),则表示不取消重复值。</p>
<p>当聚集函数遇到空值时,除<code>COUNT(*)</code>外,都跳过空值而处理非空值。<br>
因为<code>COUNT(*)</code>时对元组进行技术,某个元组的一个或者部分列取值为空不影响<code>COUNT</code>的统计结果。(或者说主键不为空,每个元组都可以相互区分。)</p>
<p>例子:计算选修1号课程的学生的平均分</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> SC
<span class="token keyword">WHERE</span> Cno<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">;</span>
</pre>
<h4 class="mume-header" id="order-by-&#x5B50;&#x53E5;">ORDER BY 子句</h4>

<p>用户可以用<code>ORDER BY &lt;列名&gt; [ASC|DESC]</code>子句对查询结果按照一个或者多个属性列的升序(<code>ASC</code>)或者降序(<code>DESC</code>)排列,默认值为升序。</p>
<p>例子:查询选修了3号课程的学生的学号及其成绩,查询结果按分数的降序排列。</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Sno<span class="token punctuation">,</span>Grade
<span class="token keyword">FROM</span> SC
<span class="token keyword">WHERE</span> Cno <span class="token operator">=</span> <span class="token string">'3'</span>
<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> Grade <span class="token keyword">DESC</span><span class="token punctuation">;</span>
</pre>
<h4 class="mume-header" id="group-by-&#x5B50;&#x53E5;">GROUP BY 子句</h4>

<pre class="language-sql"><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> <span class="token operator">&lt;</span>列名<span class="token punctuation">[</span><span class="token punctuation">,</span>列名<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token keyword">HAVING</span> <span class="token operator">&lt;</span>条件<span class="token operator">></span><span class="token punctuation">]</span>
</pre>
<p><code>GROUD BY</code>子句将查询结果按照某一列或多列的值分组,值相等的为一组。<br>
例子:求各个课程号及相应的选课人数</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Cno<span class="token punctuation">,</span><span class="token function">COUNT</span><span class="token punctuation">(</span>Sno<span class="token punctuation">)</span>
<span class="token keyword">FROM</span> SC
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Cno<span class="token punctuation">;</span>
</pre>
<p>如果分组之后,还要按一定的条件对这些组进行筛选,最终只输出满足指定条件,则需要使用<code>HAVING</code> 短语进行筛选。<br>
例子:查询选修了三门以上课程的学生学号。</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Sno
<span class="token keyword">FROM</span> SC
<span class="token keyword">GROUP</span> <span class="token keyword">BY</span> Sno <span class="token keyword">HAVING</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">3</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/*按学号分组,得到一个学生的选课,再对这个组进行计数*/</span>
</pre>
<p><code>WHERE</code>和<code>HAVING</code> 语句的区别在于作用对象不同。<br>
<code>WHERE</code> 子句多用于基本表或试图,从中选择满足条件的元组。<br>
<code>HAVING</code> 短语作用于组,从中选择满足条件的组。</p>
<h3 class="mume-header" id="&#x8FDE;&#x63A5;&#x67E5;&#x8BE2;">连接查询</h3>

<p>连接查询:简单地说就是连接表然后查询,实际上就是从多个表中选择各自的若干的属性出来,整合成一个新的表。</p>
<p>为区分不同表中相同属性名的属性列,则通过<code>表名.属性名</code>的方式来表示一个属性列。<br>
当然,如果属性名是唯一的,那么可以省略表名前缀直接写</p>
<p>例子:查询每个学生及其选课情况</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span><span class="token operator">*</span><span class="token punctuation">,</span>SC<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">FROM</span> Student<span class="token punctuation">,</span>SC
<span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno <span class="token operator">=</span> SC<span class="token punctuation">.</span>sno<span class="token punctuation">;</span>
</pre>
<p>自然连接:对于重复的列,只输出其中一个,就为自然连接</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span>Sno<span class="token punctuation">,</span>Sname<span class="token punctuation">,</span>Ssex<span class="token punctuation">,</span>Sage<span class="token punctuation">,</span>Sdept<span class="token punctuation">,</span>Cno<span class="token punctuation">,</span>Grade
  <span class="token comment" spellcheck="true">/*sno有两个,一个是Student.Sno,一个是SC.Sno,如果只输出其中一个列,就是自然连接*/</span>
<span class="token keyword">FROM</span> Student<span class="token punctuation">,</span>SC
<span class="token keyword">WHere</span> Student<span class="token punctuation">.</span>Sno <span class="token operator">=</span> SC<span class="token punctuation">.</span>sno<span class="token punctuation">;</span>
</pre>
<h4 class="mume-header" id="&#x81EA;&#x8EAB;&#x8FDE;&#x63A5;">自身连接</h4>

<p>例子:查询每一门课的间接先修课(即先修课的先修课)。</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">First</span><span class="token punctuation">.</span>Cno<span class="token punctuation">,</span>SECOND<span class="token punctuation">.</span>Cpno
<span class="token keyword">FROM</span> Course <span class="token keyword">FIRST</span><span class="token punctuation">,</span>Courst SECONDE
    <span class="token comment" spellcheck="true">/*也就是通过别名在逻辑上划分成两个表,FROM 子句后面就当两个表写,但是要加上别名*/</span>
<span class="token keyword">WHERE</span> <span class="token keyword">FIRST</span><span class="token punctuation">.</span>Cpno<span class="token operator">=</span>SECOND<span class="token punctuation">.</span>Cno<span class="token punctuation">;</span>
</pre>
<h4 class="mume-header" id="&#x5916;&#x8FDE;&#x63A5;-1">外连接</h4>

<p>例子:查询每个学生及其选课情况<br>
前面的代码是把所有选课的学生都列出来了,<br>
但是如果是所有学生的选课情况,那么还要把没选课的学生列出来。<br>
换言之,就是需要吧<code>Student</code>中的悬浮元组也列出来,也就是左外连接。</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span>Sno<span class="token punctuation">,</span>Sname<span class="token punctuation">,</span>Ssex<span class="token punctuation">,</span>Sage<span class="token punctuation">,</span>Sdept<span class="token punctuation">,</span>Cno<span class="token punctuation">,</span>Grade
<span class="token keyword">FROM</span> Student <span class="token keyword">LEFT</span> <span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span> SC <span class="token keyword">ON</span> <span class="token punctuation">(</span>Student<span class="token punctuation">.</span>Sno<span class="token operator">=</span>SC<span class="token punctuation">.</span>Sno<span class="token punctuation">)</span>
</pre>
<h4 class="mume-header" id="&#x591A;&#x8868;&#x8FDE;&#x63A5;">多表连接</h4>

<p>例子:查询每个学生的学号、姓名、选修课的课程及成绩。</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Student<span class="token punctuation">.</span>Sno<span class="token punctuation">,</span>Sname<span class="token punctuation">,</span>Cname<span class="token punctuation">,</span>Grade
<span class="token keyword">FROM</span> Student<span class="token punctuation">,</span>SC<span class="token punctuation">,</span>Course
<span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno<span class="token operator">=</span>SC<span class="token punctuation">.</span>Sno <span class="token operator">AND</span> SC<span class="token punctuation">.</span>Cno <span class="token operator">=</span> Course<span class="token punctuation">.</span>Cno<span class="token punctuation">;</span>
</pre>
<h3 class="mume-header" id="&#x5D4C;&#x5957;&#x67E5;&#x8BE2;">嵌套查询</h3>

<h4 class="mume-header" id="&#x4E0D;&#x76F8;&#x5173;&#x5B50;&#x67E5;&#x8BE2;">不相关子查询</h4>

<p>子查询的查询条件不依赖于父查询,称为 <strong>不相关子查询</strong></p>
<h4 class="mume-header" id="&#x76F8;&#x5173;&#x5B50;&#x67E5;&#x8BE2;">相关子查询</h4>

<p>如果子查询的查询条件依赖于福查询,这类子查询称为 <strong>相关子查询</strong> ,整个查询语句称为 <strong>相关嵌套查询</strong></p>
<p>例子:找出每个学生超过他自己选修课平均成绩的课程号。</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Cno
<span class="token keyword">FROM</span> SC x
<span class="token keyword">WHERE</span> Grade <span class="token operator">></span> <span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span> <span class="token function">AVG</span><span class="token punctuation">(</span>Grade<span class="token punctuation">)</span>
  <span class="token keyword">FROM</span> SC y
  <span class="token keyword">WHERE</span> x<span class="token punctuation">.</span>Sno <span class="token operator">=</span> y<span class="token punctuation">.</span>Sno  <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment" spellcheck="true">/*求这个学生选修的某个选修课的平均成绩,在和这个学生这门课的成绩比较。*/</span>
</pre>
<h4 class="mume-header" id="any-&#x6216;-some-all-&#x8C13;&#x8BCD;&#x4E0E;&#x805A;&#x96C6;&#x51FD;&#x6570;in&#x8C13;&#x8BCD;&#x7684;&#x7B49;&#x4EF7;&#x5173;&#x7CFB;">ANY (或 SOME) 、 ALL 谓词与聚集函数,IN谓词的等价关系</h4>

<table>
<thead>
<tr>
<th></th>
<th><code>=</code></th>
<th><code>&lt;&gt;</code>或<code>!=</code></th>
<th><code>&lt;</code></th>
<th><code>&lt;=</code></th>
<th><code>&gt;</code></th>
<th><code>&gt;=</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ANY</code></td>
<td><code>IN</code></td>
<td>--</td>
<td><code>&lt;MAX</code></td>
<td><code>&lt;=MAX</code></td>
<td><code>&gt;MIN</code></td>
<td><code>&gt;=MIN</code></td>
</tr>
<tr>
<td><code>ALL</code></td>
<td>--</td>
<td><code>NOT IN</code></td>
<td><code>&lt;MIN</code></td>
<td><code>&lt;=MIN</code></td>
<td><code>&gt;MAX</code></td>
<td><code>&gt;=MAX</code></td>
</tr>
</tbody>
</table>
<h4 class="mume-header" id="&#x5E26;&#x6709;-exists-&#x8C13;&#x8BCD;&#x7684;&#x5B50;&#x67E5;&#x8BE2;">带有 <code>EXISTS</code> 谓词的子查询</h4>

<p>带有 <code>EXISTS</code>  谓词的子查询不反悔任何数据,只产生逻辑真值<code>true</code> 或 逻辑假值 <code>fasle</code></p>
<p>例子:查询所有选修了1号课程的学生姓名<br>
<code>EXISTS</code>实现:</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Sname
<span class="token keyword">FROM</span> Student
<span class="token keyword">WHERE</span> <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span>
  <span class="token keyword">SELECT</span> <span class="token operator">*</span>
  <span class="token keyword">FROM</span> SC
  <span class="token keyword">WHERE</span> Sno<span class="token operator">=</span>Student<span class="token punctuation">.</span>Sno <span class="token operator">AND</span> Cno <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">/*由EXISTS引出的子查询,其目标列表达式通常都用**/</span>
</pre>
<p>连接运算实现:</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Sname
<span class="token keyword">FROM</span> Student <span class="token punctuation">,</span>SC
<span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno <span class="token operator">=</span> SC<span class="token punctuation">.</span>Sno <span class="token operator">AND</span> Cno <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
</pre>
<p><code>EXISTS</code>谓词相对应的是<code>NOT EXISTS</code>谓词。</p>
<p>一些带有<code>EXISTS</code>或<code>NOT EXISTS</code>谓词的子查询不能被其他形式的子查询等价替换。<br>
但带有<code>IN</code>谓词,比较运算符,<code>ANY</code>和<code>ALL</code>谓词的子查询都能用带有<code>EXISTS</code>谓词的子查询等价替换。</p>
<p>由于带<code>EXISTS</code>量词的相关子查询只关心内层查询效率是有返回值,并不需要查具体值,因此其效率并不一定低于不相关子查询,有时是搞笑的方法。</p>
<h3 class="mume-header" id="&#x96C6;&#x5408;&#x67E5;&#x8BE2;">集合查询</h3>

<p>集合操作主要包括:并操作<code>UNION</code>、交操作<code>INTERSET</code>、差操作<code>EXCEPT</code></p>
<p>注意:参加集合操作的各查询的结果的列数必须相同;对应项数据类型也必须相同。</p>
<h3 class="mume-header" id="&#x57FA;&#x4E8E;&#x6D3E;&#x751F;&#x8868;&#x7684;&#x67E5;&#x8BE2;">基于派生表的查询</h3>

<p>子查询不仅可以出现在<code>WHERE</code>子句中,还可以出现在<code>FROM</code>子句中,这时子查询生成的<code>临时派生表 derived table</code>成为主查询的对象。</p>
<p>例子:查询所有选修了1号课程的学生姓名</p>
<pre class="language-sql"><span class="token keyword">SELECT</span> Sname
<span class="token keyword">FROM</span> Student<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">SELECT</span> Sno <span class="token keyword">FROM</span> SC <span class="token keyword">WHERE</span> Cno<span class="token operator">=</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token keyword">AS</span> SC1
    <span class="token comment" spellcheck="true">/*AS 关键字可以省略,但必须给派生关系指定一个别名*/</span>
<span class="token keyword">WHERE</span> Student<span class="token punctuation">.</span>Sno<span class="token operator">=</span>SC1<span class="token punctuation">.</span>Sno<span class="token punctuation">;</span>
</pre>
<h2 class="mume-header" id="&#x6570;&#x636E;&#x66F4;&#x65B0;">数据更新</h2>

<h3 class="mume-header" id="&#x63D2;&#x5165;&#x6570;&#x636E;">插入数据</h3>

<h4 class="mume-header" id="&#x63D2;&#x5165;&#x5143;&#x7EC4;">插入元组</h4>

<pre class="language-sql"><span class="token keyword">INSERT</span>
<span class="token keyword">INTO</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">(</span>属性列<span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>属性列<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>常量<span class="token number">1</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>常量<span class="token number">2</span><span class="token operator">></span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</pre>
<p>例子:将一个新学生元组(学号:201215128,姓名:陈东,性别:男,所在系:IS,年龄:18) 插入到Student表中 。</p>
<pre class="language-sql"><span class="token keyword">INSERT</span>
<span class="token keyword">INTO</span> Student<span class="token punctuation">(</span>Sno<span class="token punctuation">,</span>Sname<span class="token punctuation">,</span>Ssex<span class="token punctuation">,</span>Sdept<span class="token punctuation">,</span>Sage<span class="token punctuation">)</span>
<span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'201215128'</span><span class="token punctuation">,</span><span class="token string">'陈东'</span><span class="token punctuation">,</span><span class="token string">'男'</span><span class="token punctuation">,</span><span class="token string">'IS'</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</pre>
<h4 class="mume-header" id="&#x4FEE;&#x6539;&#x6570;&#x636E;">修改数据</h4>

<pre class="language-sql"><span class="token keyword">UPDATE</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span>
<span class="token keyword">SET</span> <span class="token operator">&lt;</span>列名<span class="token operator">>=</span><span class="token operator">&lt;</span>表达式<span class="token operator">></span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token operator">&lt;</span>列名<span class="token operator">>=</span><span class="token operator">&lt;</span>表达式<span class="token operator">></span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</pre>
<h3 class="mume-header" id="&#x5220;&#x9664;&#x6570;&#x636E;">删除数据</h3>

<pre class="language-sql"><span class="token keyword">DELETE</span>
<span class="token keyword">FROM</span> <span class="token operator">&lt;</span>表名<span class="token operator">></span>
<span class="token punctuation">[</span><span class="token keyword">WHERE</span> <span class="token operator">&lt;</span>条件<span class="token operator">></span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</pre>
<h2 class="mume-header" id="&#x7A7A;&#x503C;&#x5904;&#x7406;">空值处理</h2>

<p>空值时<code>不知道</code>或<code>不存在</code>或<code>无意义</code>的值。</p>
<ul>
<li>该属性应该是一个值,但目前不知道它的具体值。</li>
<li>该属性不应该有值。</li>
<li>由于某种原因不便于填写。</li>
</ul>
<p>空值的判断:用<code>IS NULL</code> 或 <code>IS NOT NULL</code> 来表示 不能用 <code>= NULL</code></p>
<p>空值的约束条件:</p>
<ol>
<li>属性定义(或者域定义)中有 <code>NOT NULL</code>的约束条件的不能取空值。</li>
<li>加了 <code>UNIQUE</code> 限制的属性不能取空值。</li>
<li>码属性不能取空值。</li>
</ol>
<p>空值的算数运算、比较运算河逻辑运算</p>
<ul>
<li>空值与另一个值(包括空值)的算数运算的结果为空值</li>
<li>空值与另一个值(包括空值)的比较运算的结果为 <code>UNKNOWN</code><br>
有了<code>UNKNOWN</code>后,传统的逻辑运算中,二值(<code>TRUE</code>和<code>FALSE</code>)逻辑就扩展成了三值逻辑。</li>
</ul>
<h2 class="mume-header" id="&#x89C6;&#x56FE;">视图</h2>

<p>视图的用途:</p>
<ol>
<li>限制数据访问</li>
<li>能够简化用户的操作，使复杂查询简单化</li>
<li>使用户能以多种角度看待同一数据</li>
<li>对重构数据库提供了一定程度的逻辑独立性</li>
<li>对机密数据提供安全保护</li>
</ol>
<p>视图可以看做是子查询,把<code>SELECT</code>的结果保存起来,方便下次查询</p>
<p>问：为什么创建视图中不能在子查询中使用 <code>order by</code>?</p>
<ol>
<li>为了遵循 <code>ANSI-92</code> 标准?</li>
<li>视图可以看做是子查询,其结果是一个集合,与顺序无关。只有在查询的时候指定顺序才有意义。</li>
<li>其次,在查询视图的时候,可以指定<code>order by</code>来排序,如果视图本身包含了<code>order by</code>显然会冲突。</li>
</ol>
<h1 class="mume-header" id="&#x67E5;&#x8BE2;&#x4F18;&#x5316;">查询优化</h1>

<p>代数优化和物理优化</p>
<ol>
<li>
<p>选择运算尽可能先做<br>
目的:减少中间关系</p>
</li>
<li>
<p>在执行连接操作前,对关系进行适当的预处理<br>
- 在连接属性进行排序<br>
- 在连接属性上建立索引</p>
</li>
<li>
<p>投影运算和选择运行同时做<br>
目的:避免重复扫描关系</p>
</li>
<li>
<p>将投影运算与其前面或后面的双目运算结合<br>
目的:减少扫描关系的遍数</p>
</li>
</ol>
<p>物理优化:底层操作实现的优化</p>
<h1 class="mume-header" id="&#x6570;&#x636E;&#x5E93;&#x6062;&#x590D;&#x6280;&#x672F;">数据库恢复技术</h1>

<p>数据库随时都可能发生故障,会导致数据不完全,因此需要数据恢复<br>
比如,突然断电,录入操作中断,导致数据的不完全</p>
<p>数据保护的类型:</p>
<ol>
<li>安全性</li>
<li>完整性</li>
<li>并发控制</li>
<li>数据库恢复</li>
</ol>
<p>事务:用户定义个一个数据库操作序列,这些操作序列要么全都完成,要么全都不完成</p>
<p>显式定义:</p>
<pre class="language-">BEGIN TRANSACTION
	SEL&#x8BED;&#x53E5;s
COMMIT/ROOLBACK
</pre>
<p>数据的特性:(ACID特性)</p>
<ol>
<li>
<p>原子性<br>
事务不可拆分</p>
</li>
<li>
<p>一致性<br>
使数据库从一个一致性状态转移到另一个一致性状态<br>
一致性状态:数据库中只包含提交成功的结果</p>
</li>
<li>
<p>隔离性<br>
一个事务的执行,不会被其他事务干扰,并发并不影响事务的执行</p>
</li>
<li>
<p>持续性<br>
一个事务,一旦提交成功,它对数据库的改变应该是永久性的</p>
</li>
</ol>
<p>并发:应该是指同时进行同一种操作,但是这种操作的对象不相同(如果相同,这些相同对象的同种指令只能是串行执行)</p>
<h2 class="mume-header" id="&#x6545;&#x969C;&#x7684;&#x79CD;&#x7C7B;">故障的种类</h2>

<h3 class="mume-header" id="&#x4E8B;&#x52A1;&#x5185;&#x90E8;&#x6545;&#x969C;">事务内部故障</h3>

<p>某种事务再运行过程中,由于种种原因未正常运行到终止点就夭折。<br>
关键字:一个事务</p>
<p>原因可以为:</p>
<ol>
<li>输入数据有误</li>
<li>运算溢出</li>
<li>违反某些完整性限制</li>
<li>某些应用程序出错</li>
<li>并行事务发生死锁</li>
</ol>
<p>恢复操作:<br>
撤销事务(UNDO),强行回滚到事务发生之前的状态<br>
消除事务对数据的所有修改,使得这个事务像没发生过一样</p>
<h3 class="mume-header" id="&#x7CFB;&#x7EDF;&#x6545;&#x969C;">系统故障</h3>

<p>整个系统的正常运行突然被破坏,但外部存储设备上的数据未受影响。比如断电<br>
关键字:多个事务</p>
<p>恢复有两种情况:</p>
<ol>
<li>
<p>事务未完成被终端<br>
(UNDO)消除未完成的事务对数据库的修改</p>
</li>
<li>
<p>事务已完成,但还在缓存中,未写入到数据库中<br>
(REDO)将缓冲区中已完成的提交,重新运行写入到数据库中</p>
</li>
</ol>
<h3 class="mume-header" id="&#x4ECB;&#x8D28;&#x6545;&#x969C;">介质故障</h3>

<p>使存储在外存中的数据全部或部分丢失。</p>
<p>比如:</p>
<ol>
<li>磁盘损坏</li>
<li>磁头碰撞</li>
<li>操作系统的某种潜在错误</li>
<li>瞬时强电场干扰</li>
</ol>
<p>恢复:装入数据库发生故障前的数据库的某个副本(也就是使用备份)<br>
如果日志文件还没丢失,则在恢复备份之后,使用日志文件进行备份日期后面事务的redo</p>
<h3 class="mume-header" id="&#x8BA1;&#x7B97;&#x673A;&#x75C5;&#x6BD2;">计算机病毒</h3>

<p>应对方法:防火墙</p>
<h2 class="mume-header" id="&#x6570;&#x636E;&#x5E93;&#x6062;&#x590D;&#x64CD;&#x4F5C;">数据库恢复操作</h2>

<p>恢复操作的基本原理:冗余<br>
通过冗余的数据来进行数据的恢复</p>
<p>如何建立冗余的数据?&gt;</p>
<ul>
<li>数据备份</li>
<li>日志文件</li>
</ul>
<p>如何利用这些冗余的数据实施恢复?</p>
<ol>
<li>恢复备份</li>
<li>重新运行事务</li>
</ol>
<p>备份的分类</p>
<ol>
<li>
<p>静态备份和动态备份<br>
是否停止工作来进行备份,在备份结束之后再进行恢复</p>
</li>
<li>
<p>海量备份和增量备份<br>
海量备份指完全备份<br>
增量备份指指保存变化的部分</p>
</li>
</ol>
<p>上面两种方法两两组合就可产生4种备份的策略。</p>
<p>登记日志文件的格式:</p>
<ol>
<li>日志文件的格式</li>
<li>日志文件内容<br>
- ...<br>
- 有关事务的内部操作,如触发器也要记录</li>
</ol>
<p>问题:日志文件彭航地特别快,怎么缩小日志文件?</p>

    </body>
    
    
    <script>
(function bindTaskListEvent() {
  var taskListItemCheckboxes = document.body.getElementsByClassName('task-list-item-checkbox')
  for (var i = 0; i < taskListItemCheckboxes.length; i++) {
    var checkbox = taskListItemCheckboxes[i]
    var li = checkbox.parentElement
    if (li.tagName !== 'LI') li = li.parentElement
    if (li.tagName === 'LI') {
      li.classList.add('task-list-item')
    }
  }
}())    
</script>
  </html>