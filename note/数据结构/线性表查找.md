<!--toc--><!-- tocstop -->

- [线性表查找](#线性表查找)
	- [顺序查找](#顺序查找)
		- [时间复杂度](#时间复杂度)
	- [二分查找](#二分查找)
		- [时间复杂度](#时间复杂度-1)
	- [Dictionary Search（多分查找）](#dictionary-search多分查找)
	- [Fibonacci Search](#fibonacci-search)
	- [Self-organization list 自组织线性表](#self-organization-list-自组织线性表)
		- [时间复杂度](#时间复杂度-2)
		- [启发式规则](#启发式规则)
			- [根据历史访问频率排序](#根据历史访问频率排序)
			- [Move-To-Front](#move-to-front)
			- [Move-Front](#move-front)
	- [$O(1)$ 的查找方法](#o1-的查找方法)

<!-- tocstop -->

# 线性表查找
## 顺序查找

### 时间复杂度
$\theta(n)$

## 二分查找

### 时间复杂度
$\theta(\log n)$

## Dictionary Search（多分查找）

## Fibonacci Search
二分查找的一个优化，不再二分，而是根据Fibonacci序列划分查找区域

## Self-organization list 自组织线性表
自组织线性表：根据访问频率自动组织线性表结构

### 时间复杂度
$\bar{C_n} = 1p_1 + 2p_2 + 3p_3 + ... + np_n$
$p_i$为访问的概率（频率）

### 启发式规则

#### 根据历史访问频率排序
定期根据历史访问频率排序，代价可能很大，并且不具有实时性
相同频率的，先达到这个频率的在前面。
具体过程为：每访问一个值，就更新这个值的频率，然后不断往前移动，只要前面的频率小于当前这个值的频率。

#### Move-To-Front
把最近访问的元素 移动到最前面

#### Move-Front
每访问一次，元素就往前移动一定位置

注意，如果移动固定的位置，那么重复访问相邻的元素，两个元素的位置不断交换，这里访问的效率并没有得到优化的

## $O(1)$ 的查找方法
1. 直接使用数组下标访问
2. 使用散列（hash）
