[toc]

# 算法的特征
1. 输入数据
	（可有，可无）
2. 输出数据
		（至少一个）
3. 无歧义
		每一条指令没有歧义
4. 有限
		程序可以无限，算法必须有限
		算法必须在有限步骤内结束

# 算法的分析
算法分析：正确性，运算时间，占用空间，简单性，健壮性

## 时间复杂度分析
### 大O表示法
表示上界
$f(n) = O(g(n))$表示，$\exists c,N_0$,使得$\forall n > N_0$有$f(n) \leq cg(n)$

### 大$\Omega$表示法
表示下界
$f(n) = \Omega(g(n))$表示，$\exists c,N_0$,使得$\forall n > N_0$有$f(n) \geq cg(n)$

### 大$\Theta$表示法
同限
$f(n) = \Theta(g(n))$表示，$f(n) = O(g(n))  且 f(n) = \Theta(g(n))$

### 小o表示法
非紧上界（也就是不能等于）
$f(n) = o(g(n))$则有$\lim_{n \to \infty} \frac{f(n)}{g(n)} = 0$
记忆：上式移项之后 o 和 0 相近

### 小$\omega$ 表示法
非紧下界
$f(n) = \omega(g(n))$则有$\lim_{n \to \infty} \frac{f(n)}{g(n)} = \infty$
记忆：上式移项之后 $\omega$ 和 $\infty$ 相近

## 考试题型
### 求时间复杂度
### 证明题
> 证明： O(f(n))+O(g(n)) = O(max{f(n),g(n)})
证明：
对于任意f1(n) $\in$ O(f(n)) ，存在正常数c1和自然数n1，使得对所有n $\geq$ n1，有f1(n) $\leq$ c1f(n) 。
类似地，对于任意g1(n) $\in$ O(g(n)) ，存在正常数c2和自然数n2，使得对所有n $\geq$ n2，有g1(n) $\leq$ c2g(n) 。
令c3=max{c1, c2}， n3 =max{n1, n2}，h(n)= max{f(n),g(n)} 。
>则对所有的 n $\leq$ n3，有
f1(n) +g1(n) $\leq$ c1f(n-) + c2g(n)
    $\leq$ c3f(n) + c3g(n)= c3(f(n) + g(n))
    $\leq$ c32 max{f(n),g(n)}
    = 2c3h(n) = O(max{f(n),g(n)}) .
>证毕。


![6]

![7]
![8]

## 常用公式
![1]![2]![3]![4]![5]![9]


# 分治
分治：分而治之，将大问题分解成小问题，然后把小问题的解合并成大问题的解。

## 使用条件
1. 问题的规模缩小到一定程度可以解决
2. 可以分解成若干个问题规模较小的相同问题
3. 子问题的解可以合并成该问题的解
4. 子问题是相互独立的

PS:若只具备前两个条件，而不满足第三个条件，那么可以考虑贪心算法 ， 动态规划

## 步骤
1. 分解问题
2. 解决子问题
3. 合并子问题的解

## 案例
1. 二分搜索
2. strassen 矩阵相乘
3. 大数相乘
4. 汉诺塔问题
5. 快速排序
6. 归并排序
7. 整数划分
8. 全排列问题

# 递归
递归：直接或间接调用自身的算法
双递归函数：函数的一个参数为它自身的调用。

## 递归的求解方法
### 代入法
猜测+数学归纳

### 递归树法
就是把每一层的运行的次数计算出来，然后求和

### 主方法
主方法实际上就是对递归树法的一个归纳。
对于形如以下的递归式：
$T(n) = aT(\frac{n}{b}) + f(n)$
主要分为三种情况：
1. 叶子节点为主
如果$\exists \epsilon > 0$使得$f(n) = O(n^{\log_b{a} - \epsilon})$
则 $T(n) = \Theta(n^{\log_b{a}})$

2. 平均分布
如果$f(n) = \Theta(n^{\log_b{a}})$
则 $T(n) = \Theta(n^{\log_b{a}}\log{n})$

3. 根占主
	如果$\exists \epsilon > 0$使得$f(n) = \Omega(n^{\log_b{a} + \epsilon})$

	并且$\exists c < 1$使得$af(\frac{n}{b}) \leq cf(n)$

	则 $T(n) = \Theta(n^{\log_b{a}})$

#### 注意
1. 以下默认成立，可以不用证明
$\nexists c > 0$使得$\forall \epsilon,n^{\epsilon} < c \log n$

2. 不是所有的都能用书方法
	1. $T(n) = 2T(\frac{n}{2}) + n \log n$
		此处$n\log n \neq \Omega(n^{1 + \epsilon})$


### 一般形式公式法

# 动态规划
动态规划与分治的区别：分治算法中，相同的子问题会重复计算，而动态规划中，相同的子问题只计算一次。
也就是动态规划解决子问题重叠的问题。


1. 最优子结构性质
当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。

2. 重叠子问题性质

最优值和最优解：最优值通过最优解计算得到，比如矩阵连乘的最少次数通过某个矩阵相乘的次序（最优解）计算得到

## 动态规划的基本步骤
1. 找出最优解的性质，并刻划其结构特征。
2. 递归地定义最优值。
3. 以自底向上的方式计算出最优值。
4. 根据计算最优值时得到的信息，构造最优解。

# 贪心
贪心算法：每一次都选择局部最优解，达到最后局部最优解也是全局的最优解。

贪心算法每一次只作一次选择。

每个贪心算法之下，几乎总一个更繁琐的动态规划算法。

在贪心算法中，我们总是做出当前看来最佳得分选择，然后求解剩下的唯一的子问题。

贪心算法的证明，通常首先考虑某个子问题的最优解，然后用贪心选择来代替某个其他选择来修改此解，从而得到一个相似但更小的子问题。

# 回溯法
回溯法可以理解成以下等式：
回溯法 = dfs + 剪枝

剪枝的方法一般有以下几种情况：
1. 先预处理出某个近似解，把一些差距很大的解排除掉
2. 当前局部解和当前最优解进行比较，如果没有比最优解更优，那么可以剪去
3. 预测目标解的值，把不可能的提前排除
		这个情况有时候包含了上面第二种方式



[9]:assets/算法设计与分析-4cc03.png
[8]:assets/算法设计与分析-865aa.png
[7]:assets/算法设计与分析-dfe8f.png
[6]:assets/算法设计与分析-e5541.png
[5]:assets/算法设计与分析-edd7f.png
[4]:assets/算法设计与分析-f95bb.png
[3]:assets/算法设计与分析-df28f.png
[1]:assets/算法设计与分析-fdca9.png
[2]:assets/算法设计与分析-b3e90.png
