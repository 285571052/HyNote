\documentclass[UTF8,a4paper]{ctexart}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr,hyperref,xcolor,amsmath}

\newcommand\hl{\bgroup\markoverwith
  {\textcolor[rgb]{0.9, 0.99, 0.9}{\rule[-.5ex]{2pt}{2.5ex}}}\ULon}

\pagestyle{fancy}
\hypersetup{hidelinks}

\lhead{\bfseries \leftmark}
\chead{}
\rhead{SCUT}
\lfoot{\url{https://github.com/285571052}}
\cfoot{qhy}
\rfoot{\thepage}
\setlength{\headheight}{13pt}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\setlength{\parindent}{0pt}
\newcommand{\spaceline}{\vspace{\baselineskip}}

\author{ qhy }
\date{\today}
\title{编译原理}

\begin{document}
  \maketitle
  \tableofcontents
  \newpage

  \section{介绍}

  \textbf{预期收货}:
  \begin{itemize}
    \item 通过学习编译原理,写出更高效的代码
    \item 针对目标,自编写编译器

    对某个模型机的编译器进行设计
  \end{itemize}

  \textbf{编译器和解释器的区别?}\\
  编译器是转换器,解释器是执行系统。

  \spaceline

  程序编译的过程主要分为两大阶段:
  \begin{itemize}
    \item [1.] 查错
    \begin{itemize}
      \item 词法分析
      \item 语法分析
      \item 语义分析
    \end{itemize}

    \item [2.] 综合(翻译)
    \begin{itemize}
      \item [1.] 产生中间代码进一步优化
      \item [2.] 目标代码生成
    \end{itemize}
  \end{itemize}

  高级程序处理过程:初始源程序$\to$预处理$\to$源程序$\to$编译$\to$目标汇编$\to$机器代码

  注:生成机器代码的时候,并不是直接生成,而是先生成对应的汇编代码,再生成机器代码。

  编译过程:每个阶段的输出作为下一个阶段的输入(即数据从一种形式转换成另一种形式)。

  编译过程的每个阶段都包括两个相同的处理:表格管理和出错处理。

  表格管理是保存编译过程每个阶段的数据和结果,出错处理则是对编译过程遇到的语法,词法等错误进行处理。

    \subsection{词法分析}
    主要分为两大步骤,扫描和分解

    扫描为从左到右扫描

    分解为以介符对语句进行分割(注:双引号内的介符不可划分)

    最后结果使用一个二元组保存,格式为(种类,值)

    \subsection{语义分析}
    语义分析:不断构造语法树

    如:类型不对,数组越界等

    过程:单词符号串$\to$语法分析$\to$语法短语

    识别规则:描述程序结果的规则,通常由递归规则表示。

    输出:合法的语法树

    \subsection{语义分析}
    语义分析:包括静态语义和动态语义

    常见的错误包括类型不匹配,数组越界等

    输出:生成中间代码

    结果使用四元式表示,格式为:(运算符,运算对象1,运算对象2,结果)

    \subsection{代码优化}
    代码优化:对代码进行优化化简

    \subsection{目标代码生成}
    目标代码生成:与目标机器紧紧相关,先生成对应的汇编代码,再生成机器代码

    \subsection{表格管理与出错处理}
    表格管理与出错处理:每个阶段都执行这一操作

    \subsection{编译程序划分}
    编译程序划分:分析与综合(翻译)两个阶段

    按是否与目标机器相关:前端(无关)和后端(相关)

  \section{文法和语言}

  掌握自下而上和自上而下的分析方法。

  \spaceline
  \textbf{程序设计的定义:}语言是一个记号系统。

  \textbf{分析程序设计语言的两个阶段:}$\left \{\begin{array}{l} \text{每个程序的构成规律}\\\text{每个程序的含义}\end{array} \right .$

    \subsection{语法}
    \textbf{语法:}是一组规定,用它可以形成和产生一个合适的程序。

    描述工具:文法

    语法只可以判断结构是否合法。

    \subsection{语义}
    \textbf{语义:}$\left \{ \begin{array}{l}\text{静态语义}\\\text{动态语义} \end{array} \right.$

    \spaceline

    \textbf{静态语义:}一系列限定的规则,确定哪些合乎语法的程序是合适的。

    \textbf{动态语义:}运行或动态链接时进行的判断。

    描述工具:指称语义,操作语义

    作用:检查类型匹配,变量作用域等。

    \subsection{文法}
    \textbf{如何描述语句?}
    \begin{itemize}
      \item [1.] 生成方式(文法)\\
      语言中每个句子可以用严格定义的规则进行构造
      \item [2.] 识别方式(自动机)\\
      用一个过程,经有限次计算后会停止回答"是" ,若属于句子,要么回答"否",要么永远持续下去
    \end{itemize}

    \spaceline
    \textbf{语言:}可以是有穷的也可以是无穷的,我们要做的是,找出语言的有穷表示。

    \textbf{文法的作用:}
    \begin{itemize}
      \item [1.] 使用有穷的规则描述无穷的语言
      \item [2.] 严格定义句子的结构,是判断句子结构是否合法的依据
    \end{itemize}

    \textbf{方法:}\\
    \hl{::=}表示定义一条规则\\
    \hl{$\Rightarrow$}表示应用这条规则,完成句子的变换(即由...推导出...的意思)

      \subsubsection{符号和符号串}
      \textbf{字符表(符号集):}由字母、数字和若干专用字符组成的非空有限集合。

      \textbf{符号串:}字母表中的符号组成的任何有穷序列。

      比如:$a,aca$是$A:\{a,b,c\}$的符号串。

      符号串的长度:符号串含有符号的个数

      符号串的运用:
      \begin{itemize}
        \item 连接\\
        定义:$x = "ST", y = "aby"$\\
        则$xy = "STaby"$

        \item 方幂\\
        $a^n = \begin{array}{c}\underbrace{aa\cdots aa}\\ \text{n个a} \end{array}$

        \item 集合的乘积\\
        定义:$A = \{a,b\} , B = \{0 ,1\}$\\
        则$AB = \{a0 , a1 , b0 , b1\}$\\
        注:A,B是符号串的集合,并且AB的结果中A的符号串在前面\\

        \item 集合的方幂\\
        $A^2 = AA$
      \end{itemize}

      \subsubsection{闭包}
      \textbf{闭包:}$\Sigma$的闭包为$\Sigma$上所有元素组合的集合$\Sigma^*$。即
      \begin{equation}
        \Sigma^* = \Sigma^0 \bigcup \Sigma^1 \bigcup \Sigma^2 \cdots
      \end{equation}

      \textbf{正闭包}:闭包去掉空集元素。即
      \begin{equation}
        \Sigma^+ = \Sigma^* - \{\phi\}
      \end{equation}

      \subsubsection{文法}
      \textbf{产生式(规则):}一组有序对$(\alpha , \beta)$ 表示$\alpha \to \beta$ 或$\alpha ::= \beta$

      \textbf{文法的定义:}四元组$(V_N,V_T , P , S)$

      其中,$V_N$表示非终结符 , $V_T$表示终结符 , $P$表示产生式集合,$S$表示文档其实符号。

      注:
      \begin{itemize}
        \item $S$为文档的其实符号,从具体情况上看,它就是句子本身,只是还没有经过解析。
        \item $V_N \bigcup V_T = 字母表$
      \end{itemize}

      例子:

      文法$G = (V_N,V_T , P , S)$\\
      $V_N = \{S\}, P = \{S \to 0S1 , S\to 01\}, V_T = \{0,1\}$\\
      开始符号为 $S$

      \spaceline
      文法$G = (V_N,V_T , P , S)$\\
      $V_N = \{\text{标识符,字母,数字}\}$\\
      $ V_T = \{a,b,\cdots,z,0,1,\cdots , 9\}$\\
      $P = \left \{
      \begin{array}{l}
      <\text{标识符}> \to <\text{字母}>,\\
      <\text{标识符}> \to <\text{标识符}><\text{字母}>,\\
      <\text{标识符}> \to <\text{标识符}><\text{数字}>, \\
      <\text{字母}> \to a,\\
      \cdots ,\\
       z,<\text{字母}>\\
       <\text{数字}> \to 0,\\
       \cdots ,\\
        9,<\text{数字}>
      \end{array}\right \}$\\
      $S = <\text{\text{标识符}}>$

      \subsubsection{简化表示}
      简化表示:只使用产生式来表示文法,四元组的其他三元在产生式中表示。
      \begin{itemize}
        \item 第一条产生式的左部表示$S$
        \item 用大写字母或者尖括号包围表示非终结符集合
        \item 用小写字母表示终结字符集合
        \item 左部相同的产生式的多个,可以用\hl{$|$}(或) 来简化表示。\\
        比如:$A\to \alpha , A \to \beta$可以简记为$A \to \alpha | \beta$\\
        注意:$A \to \alpha | \beta$表示的是两条产生式而不是一条,其中$\alpha , \beta$为候选式。
      \end{itemize}

    \subsection{归纳与推导}
    \textbf{直接归纳与直接推导:}\\
    若$v\Rightarrow w$则称$v$直接推导$w$ 或 $w$ 直接归纳为 $v$

    \spaceline

    \textbf{归纳与推导:}使用了多条产生式,记为
    \begin{equation}
      \renewcommand{\arraystretch}{0.5}
      S \begin{array}{c} + \\ \Rightarrow \end{array} \alpha
    \end{equation}
    或
    \begin{equation}
      \renewcommand{\arraystretch}{0.5}
      S \begin{array}{c} * \\ \Rightarrow \end{array} \alpha
    \end{equation}

    注:如果使用了一条产生式,进行了多次$\Rightarrow$也为直接推导, 推导是使用了多条产生式。

    \subsection{句型、句子、语言}
    \textbf{句型与句子的定义:}\\
    对于文法$G[S]$,若$\renewcommand{\arraystretch}{0.5}S \begin{array}{c} * \\ \Rightarrow \end{array} x$ ,则称$x$为文法$G$的句型。\\
    若$x$仅由终结符组成,则称$x$为文法$G$的句子

    注:
    \begin{itemize}
      \item 句型可以表示多个句子,句子是句型的一个情况之一。句子也是一个句型。
      \item 起始符也为句型,即\\
      隐含条件:$S\to S$ , 所以$S$也是文法$G$的句型。
    \end{itemize}

    \spaceline
    \textbf{语言$L[G]$的定义:}语言$L[G]$是文法$G[S]$的所有句子的集合。

    注:
    \begin{itemize}
      \item $+,(,*,$等出现在句子中的成分,也是终结符。
      \item 可以通过产生式的具体表达,判断出某个操作的优先级。
    \end{itemize}

    \spaceline
    \textbf{文法的等价:}\\
    若$L[G_1] == L[G_2]$ ,则称文法$G_1$ 和 文法$G_2$ 等价。

    \spaceline
    \textbf{文法的种类:}
    \begin{itemize}
      \item 0型文法
      \item 1型文法(上下文相关文法)
      \item 2型文法(上下文无关文法)\\
      大部分程序设计语言是2型文法
      \item 3型文法(正规文法)\\
      一般用来定义一个单词
    \end{itemize}

  \section{上下文无关文法及其语法树}
  上下文无关文法:2型文法,有足够的能力描述现今程序设计语言的语法结构

  例子:算数表达式:
  $E\to i|E+E|E*E|(E)$\\
  $<\text{赋值语句}> \to i := E$\\
  $<\text{条件语句}> \to if <\text{条件}> then <\text{语句}>$\\
  $| if <\text{条件}> then <\text{语句}> else <\text{语句}>$

  \subsection{规范推导和规范句型}
  \textbf{最左/右 推导}:\\
  在推导任何一步$\alpha\to \beta$时,其中$\alpha,\beta$为句型,都是对$\alpha$中的最左/右的
  非终结符进行替换,则成为最左/右推导。

  {\color{red}明确???推导到底是多次直接推导,还是多条产生式}

  \textbf{规范推导:}最右推导\\
  \textbf{规范规约:}最左规约

  \textbf{语法树:}推导的过程,可以展开成语法树,但是从语法树是看不出语法树的构造顺序的(即推导的过程)\\
  在语法树上,从左到右读取叶子节点,可以得到句型或句子。

  \textbf{语法树的定义:}满足下面几个条件的树,则称为文法G的语法树。
  \begin{itemize}
    \item 每个节点都有标记,是终结符或者非终结符中一个符号
    \item 根节点的标记是起始符(S)
    \item 若一个节点至少有一个除它自己之外的子孙,则这个节点的标记一定是非终结符
    \item 语法树得到的一定是文法G的产生式
  \end{itemize}

  \textbf{文法的二义性:}\\
  一个文法存在某个句子对应2个不同的语法树,则称文法有二义性。

  \subsection{句型的分析}
  \textbf{句型的分析:}识别给定串是否是某文法的句型。

  句型的分析主要有两种方法:
  \begin{itemize}
    \item 自上而下的分析法(推导)
    \item 自下而上的分析法(规约)
  \end{itemize}

  \textbf{自上而下的算法:}从开始符出发,反复使用文法中的产生式,
  寻找匹配的推导。(从跟节点开始不断构造语法树,找出与给定串匹配的语法树)\\
  这个算法的关键之处是\textbf{如何选择产生式?}

  \spaceline
  \textbf{自下而上的算法:}从给定串出发,归约到起始符(从叶子节点出发,向上构造语法树)\\
  这个算法的关键之处是\textbf{如何确定可归约串????????}

  \spaceline
  要确定可归约串,首先要了解\textbf{短语,直接短语,句子}的概念。{\color{red}为什么?回头需要去看算法的原理}\\
  \textbf{短语:}若$\renewcommand{\arraystretch}{0.5}S\begin{array}{c} * \\ \Rightarrow \end{array} \alpha A\delta
  \begin{array}{c} * \\ \Rightarrow \end{array} \beta$,则称$\beta$是句型{\color{red}$\alpha A \delta$}相对于$A$的短语。
    (从语法树上来看,短语就是叶子 或者 叶子与其父(祖宗)节点 的组合对应的句型 )

  {\color{red}到底是句型$\alpha A \delta$ 还是 句型$\alpha \beta \delta$}

  直接短语:若$\renewcommand{\arraystretch}{0.5}S\begin{array}{c} * \\ \Rightarrow \end{array} \alpha A\delta
   {\color{red}\Rightarrow}  \beta$,则称$\beta$是句型{\color{red}$\alpha A \delta$}相对于$A$的直接短语。
   (从语法树上来看,每个叶子都是直接短语)

   \textbf{句柄:}一个句型的最左直接短语为句柄(从语法树上来看,最左的叶子就是句柄)\\
   \textbf{可归约串}:句柄即可归约串。

   \spaceline
   \textbf{多余规则:}
   \begin{itemize}
     \item 不可到达
     \item 不可终止
   \end{itemize}

\end{document}
