<!--toc-->

- [描述](#描述)
	- [最优子结构](#最优子结构)
	- [求一个递归的解](#求一个递归的解)
	- [从c矩阵中还原最优解](#从c矩阵中还原最优解)
		- [还原所有的LCS](#还原所有的lcs)
	- [其他优化](#其他优化)

<!-- tocstop -->

# 描述

## 最优子结构
令$X=\{x_1,x_2,...,x_n\},Y=\{y_1,y_2,...,y_m\}$为两个序列，$Z=\{z_1,z_2,...,z_k\}$为X和Y的任意一个最长公共子序列(LCS)。
1. 若$x_n == y_m$ 那么一定有$x_n = y_m = z_k$
    则$Z_{k-1}$是 $X_{n-1}$和 $Y_{m - 1}$的最长公共子序列

2. 若$x_n \neq y_m$且 $x_n \neq z_k$，那么Z是$X_{n-1}$和Y的一个LCS

3. 若$x_n \neq y_m$且 $y_m \neq z_k$，那么Z是$Y_{m-1}$和X的一个LCS

## 求一个递归的解
两个序列分别表示成a[1;n],b[1,m]，
令c[i,j]表示a和b的两个字串a[1;i]和b[1;j]的最长公共字串
那么有

$c[i,j]=\begin{cases}
0 &,i = 0 \,or\, j = 0\\
c[i - 1,j - 1] + 1 &,a[i] = b[j] \\
max(c[i-1,j],c[i,j-1]) &,a[i]\neq b[j]
\end{cases}$

## 从c矩阵中还原最优解
矩阵的值第一次发生变化（加一）的位置就一定是最长公共字串的一个部分，从右下角开始，不断地往左上角移动每次到达一个转折的地方，那个点对应值一定是某个LCS的一部分。

简单的说，
1. 就是从当前点出发，向上移动，然后再向左移动，直到对应矩阵位置的值不一样。然后停留的点就是输出的点
2. 从停留的点左上角那个点开始，重复第一步，直到i=0 或者 j=0 时，输出的全部的字符。（这样输出的子序列是逆序的。）

3. 还有一种情况，就是判断a[i] 和 b[j]是否相等，是则来向可能是左上角。

```cpp
//参考代码
```

### 还原所有的LCS
还原所有的LCS，方法就是根据上面的思路，每次i，j移动的时候，有3个方向，
一个是先向上移动，然后再向左移动
一个是先向左移动，再向上移动
这样，最终停留的点的位置是可能不一样的，也就是说，输出的字符不一样的，那么枚举所有的方向，就能还原出所有的子序列了。
还有一个是当a[i] == a[j]的时候，直接输出当前对应的字符。

```cpp
//参考代码
```

进一步优化：实际上，有时候 先向上和先向下 移动，最终停留的位置都是一样的，那么可以两个方向先移动，但不继续往下走，先判断两个终点是否一样，再考虑决定是否要分支走。

```cpp
//参考代码
```


然而，就算经过上面的优化，得到的结果也只能保证子序列的下标序列不会被重复枚举到，但是确无法保证对应的字符串是否重复，所以 最终还是需要先把所有的LCS列举出来时候，去重复才能得到LCS的数目（实现上是得到一个LCS的时候判断一下是否重复会好一些）
```
//参考代码
```

## 其他优化
如果只是求最优值，而不关心最优解，那么在递推的时候可以用滚动数组来节省内存空间。
