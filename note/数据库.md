[toc]

# 学习目标
![1]

# 考核方式
![2]

# 如何提高水平
![3]

# 数据库
1. 数据
2. 数据库
  就是数据的集合
3. 数据库管理系统
  支持一下功能
    1. 数据的定义
    2. 数据的组织，存储，管理
    3. 数据的操纵
    4. 数据的建立和维护
    5. 数据的事务管理和运行管理
    6. 其他

人工管理的缺点：
1. 不保存
2. 直接通过应用程序管理数据
3. 不共享
4. 不独立

文件系统：
1. 长期保存
2。 由文件系统管理
3. 冗余度大
4. 独立性差

数据库：
1. 数据结构化
2. 共享性高， 冗余度低
3. 独立性强
4. 数据由数据库管理系统统一管理和控制

# 数据库的分类
非关系型模型:层次模型，网状模型，由于这两种模型难以表达数据，因此没有普及，也因此不讲

关系型模型:比前面两个模型更加简化的模型，又叫作 表，二维表，是当前(2017-3)主流的数据库模型

## 关系型模型
逻辑上，所有的数据由一个个表组成，但物理上还是基于文件系统的。

~~一个图~~

每一个实体由一行组成，每一行又叫做元组，或者记录
域:属性的取值范围
度不能太大

随着日志的规模越来越大，如果数据都放在一个表中，那么速度会越来越慢


问:主码和码的区别?
码:由实体间相互区分的属性构成，即码的值不可以重复，但是码可以有多个。也就是说只要属性值不重复的属性都可以称为码（名字如果没有重复的话，也可以是码）
主码:主码只能有一个，但是不是指一个属性，可以由多个属性联合表示，但是它必须可以唯一确定一个元组。

问:关系型数据无法处理表中嵌套表的表示，那这个情况要怎么表达？
上面的意思是，一个表中的属性不可以再次区分，（也就是属性不能是表），这个时候可以把表嵌套表的数据拆分成多个表来表示（也就是嵌套的表再次拆分出来）。

## 关系型数据的约束性
1. 实体完整性
2. 参照完整性
3. 用户定义的完整性

# 数据库系统的结构
0. 单用户数据系统
1. 主从式数据库系统

2. 分布式数据库系统
    主要是数据的同步和处理

3. C/S结构数据库
    比如，360的病毒库，手机app

4. B/S 服务器结构
    能简化应用操作的复杂性

5. 嵌入式数据库
    数据库的规模小

# 数据库的模式结构
三级模式结构
外模式:通过视图/应用该程序 来访问数据，对用户来说，这个是不透明的（也就是用户只关心拿到的数据，而不关心数据内部的结构）


# 关系代数
关系代数是一种抽象的查询语言，它同对关系的运算来表达查询。
关系袋鼠的运算按运算符的不同分为两种：
1. 传统的集合运算
    主要包括，并，交，差，笛卡儿积
2. 专门的关系运算

|集合运算符|含义|
|-|-|
|$\cup$|并|
|$\cap$|交|
|$-$|差|
|$\times$|笛卡儿积|

|关系运算符|含义|
|-|-|
|$\sigma$|选择|
|$\Pi$|投影|
|$\Join$|连接|
|$\div$|除|

## 关系运算
### 选择
选择：在关系R中选择满足给定条件F的诸元组（从行中选择行）
$\sigma_F(R)$

### 投影
投影：从关系R中选择若干属性组成新的关系（即从列中抽取列出来组成一个新的表）
注意：投影的结果是会去重复的。
比如，投影性别，结果是{男，女}，而不是{男，男，女，女}
$\Pi_A(R)$

### 连接
从两个关系的笛卡尔积中选择属性间满足一定关系的的元组。
$\begin{matrix}
R \Join S \\
\scriptsize{A  \Theta B}
\end{matrix}$

### 等值连接
$\begin{matrix}
R \Join S \\
\scriptsize{A  = B}
\end{matrix}$
表示从关系R和S的笛卡儿积中，选择A和B属性值相等的i那些元组。（A是R的属性，B是S的属性）

### 自然连接
自然连接是特殊的等值连接，它要求两个属性名必须相同。
取 等值连接的两个属性名相同的列出来 组成一个新的表。并且两个同名的属性，只保留一个下来。

### 外连接
在自然连接的时候，不存在属性值相等的元素，那么就会被丢弃。
被丢弃的元组称为悬浮元组。
如果保留这些悬浮元组。那么就称为外连接。
如果只保留左边关系R中的悬浮元组，称为左外连接
如果只保留右边关系S中的悬浮元组，称为右外连接

## 除
$R \div S = T$
结果T包含了在R但不在S中的属性及值，且T的元组与S的元组的所以组合都在R中。

# 结构化的查询语言 SQL语言
结果来自同一个表，但是不是一次遍历得到的时候，应该使用更名运算，逻辑上把一个表看作两个表，理解成内容相同的两个表经过一次遍历得到结果（之所以是要更名，就是为了区别这两个逻辑上的表，否则表达式就有歧义了）

基本表是本身独立存在的表，在关系数据库管理系统中一个关系就对应一个基本表。一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。

## 数据定义
一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表，试图，索引等数据对象

### 模式的定义和删除
#### 定义模式
```sql
CREATE SCHEMA <模式名> AUTHORIZATION <用户名>;
```

如果没有指定 `<模式名>`，那么 `<模式名>` 就隐含为 `<用户名>`

例子：为用户 `WANG` 定义一个学生-课程模式 S-T
```sql
CREATE SCHEMA "S-T" AUTHORIZATION WANG
```

#### 删除模式
```sql
DROP SCHEMA <模式名><CASCADE|RESTRICT>
```
`CASCADE`:级联，表示在删除模式的同时，把该模式中所有的数据库对象都删除。
`RESTRICT`:限制，表示如果该模式中已经定义了下属的数据库对象，则拒绝该删除语句的执行。

### 基本表的定义、删除、修改
#### 定义基本表
```sql
CREATE TABLE <表名> (<列名><数据库类型>[列级完整性约束条件]
[,<列名><数据库类型>[列级完整性约束条件]]
...
[,<表级完整性约束条件>]);
```

例子:建立一个"学生"表 Student
```sql
CREATE TABLE Student
  (Sno CHAR(9) PRIMARYKEY;
      /* `Sno` 是主码*/
  Sname CHAR(20) UNIQUE,
      /*取值唯一的列*/
  Ssex CHAR(2),
  Sage SMALLINT,
  Sdept CHAR(20)
    );
```

约束条件:
`UNIQUE`：取值唯一的列名；
`PRIMARY KEY`：主关键字（主码）列名；
`NOT NULL`：列值不能为空值；
`FOREIGN KEY`：外部码列名；
`REFERENCES`：引用的外部码的表名和列名
`CHECK`:满足某个条件

`UNIQUE`,`PRIMARY KEY`:
```sql
CREATE TABLE   dept(
	deptno 	  char(2),
	dname	  VARCHAR(14),
	loc	  VARCHAR(13),
	CONSTRAINT dept_dname_uk UNIQUE (dname),
	CONSTRAINT dept_deptno_pk PRIMARY KEY(deptno));
```


`FOREIGN KEY`:既可在列级定义也可以在表级定义
```sql
CREATE TABLE emp(
	empno 	char(4),
  	ename	VARCHAR(10) NOT NULL,
  	job	VARCHAR(9),
  	mgr	NUMERIC(4),
  	hiredate	DATETIME,
  	sal	NUMERIC(7,2),
   	comm	NUMERIC (7,2), --佣金
  	deptno	NUMERIC(7,2) NOT NULL,
	CONSTRAINT emp_deptno_fk FOREIGN KEY (deptno)
			REFERENCES dept (deptno))
```

`CHECK`:
```sql
CONSTRAINT emp_deptno_ck  
            CHECK (DEPTNO BETWEEN 10 AND 99),
```

##### 数据类型
|数据类型|含义|
|-|-|
|CHAR(n),CHARACTER(n)|长度为n的定长字符串|
|VARCHAR(n),CHARACTERVARYING(n)|最大长度为n的变长字符串|
|CLOB|字符串大对象|
|BLOB|二进制大对象|
|INT,INTEGER|长整数(4字节)|
|SMALLINT|短整数(2字节)|
|BIGINT|大整数(8字节)|
|NUMERIC(p,d)|定点数,由p位数字(不包括符号,小数点)组成,小数点后面有d位数字|
|DECIMAL(p,d),DEC(p,d)|同NUMERIC|
|REAL|取决于机器精度的单精度浮点数|
|DOUBLE PRECISION|取决于机器精度的双精度浮点数|
|FLOAT(n)|可选择精度的浮点数,精度至少为n位数字|
|BOOLEAN|逻辑布尔量|
|DATE|日期,包含年、月、日,格式为YYYY-MM-DD|
|TIME|时间,包含一日的时、分、秒,格式为HH:MM:SS|
|TIMESTAMP|时间戳类型|
|INTERVAL|时间间隔类型|

#### 模式与表
每一个基本表都属于某个模式,一个模式包含多个基本表。
那怎么关联这个模式和表?有三种方法。
1. 在表名明显地给出模式名
    ```sql
    CREATE TABLE "S-T".Student(...); //Student 所属的模式是 S-T
    ```

2. 在创建模式的语句中同时创建表
    也就是创建模式的语句后面,紧跟创建表的语句。

3. 设置所属的模式,这样在创建表时表名不必给出模式名
    ```sql
    SET search TO "S-T",PUBLIC;
    CREATE TABLE Student(...);
    ```

#### 修改表
SQL语言用`ALTER TABLE` 语句来修改基本表。
```sql
ALTER TABLE <表名>
[ADD [COLUMN]  <新列名><数据类型> [完整性约束]]
[ADD <表级完整性约束>]
[DROP [COLUMN] <列名> [CASCADE|RESTRICT]]
    /*CASCADE:自动删除引动该列的对象,RESTRICT:如果已经有引用,则拒绝删除*/
[DROP CONSTRAINT<完整性约束> [RESTRICT|CASCADE]]
    /*CONSTRAINT 用于删除指定的完整性约束条件*/
[ALTER COLUMN <列名><数据类型>]
    /*用于修改原有的列定义*/
```

#### 删除基本表
```sql
DROP TABLE <表名> [RESTRICT|CASCADE]
    /*默认是 RESTRICT*/
```

### 索引的建立与删除
一般说来,建立与删除索引由数据库管理员或表的 **属主**( **owner** ),即建立表的人,负责完成。
用户不必也不能显示地选择索引。
索引是关系型数据库管理系统的内部实现技术,属于内模式的范畴。

可以动态地定义索引，即可以随时建立和删除索引；

不允许用户在数据操作中引用索引。索引如何使用完全由系统决定，这支持了数据的物理独立性；

一个表上可建多个索引。索引可以提高查询效率，但索引过多耗费空间，且降低了插入、删除、更新的效率；

建立索引的两个主要目的：加快查询速度、保证行的唯一性。

* 下列情况，需要建立索引
    * 列取值范围较大时
    * 在WHERE或连接条件中频繁使用的列
    * 列包含大量的非空值
    * 查询少于2-4%行的大表
* 下列条件不要创建索引:
    * 小表
    * 列并不频繁用在查询条件中
    * 查询超过2–4%的行
    * 表频繁被更新（如操作日志表、事件表）


#### 建立索引
```sql
CREATE [UNIQUE] [CLUSTER] INDEX <索引名>
ON <表名>(<列名> [<次序>] [,<列名> [<次序>] ...]);
    /* 次序由两种选择:ASC:升序,DESC:降序
     * CLUSTER 表示要建立的索引是聚簇索引
     * UNIQUE 表明此索引的每一个索引值只对应唯一的数据记录
     */
```

#### 修改索引
```
ALTER INDEX <旧索引名> RENAME TO <新索引名>
```

#### 删除索引
```
DROP INDEX <索引名>
```

## 数据查询
```sql
SELECT [ALL|DISTINCE] <目标列表达式> [,<目标列表达式>] ***
FROM <表名或视图名> [,<表名或视图名>] | (<SELECT 语句>) [AS] <别名>
    /*别名的命名方式:在下一个列之前(逗号之前)加上 "[空格]别名"*/
[WHERE <条件表达式>]
    /*根据WHERE子句的条件表达式从FROM子句指定的基本表、视图或派生表中找出满足条件的元组,再按SELECT 子句的目标列表达式选出元组中的属性形成结果表*/
[GROUD BY <列名1> [HAVING <条件表达式>]]
    /* 将结果按<列名1>的值进行分组,该属性列值相等的元组为一个组。通常会再每组中作用聚集函数
     * HAVING 短语,只有满足制定条件的组才予以输出。 */
[ORDER BY <列名2> [ASC|DESC]];
```

### 单表查询
#### 选择表中的若干列
也就是决定输出哪些列(属性)
##### 查询指定列
查询全体学生的学号与姓名
```sql
SELECT Sno,Sname
FROM Student;
```

#####  查询全部列
即以 `*` 号省略列名的书写
查询全体学生的详细信息
```sql
SELECT *
FROM Student;
```

#####  查询经过计算的值
查询全体学生的姓名及其出生年份(只知道学生的年龄)
```sql
SELECT Sname,2014-Sage
FROM Student
```

目标列不仅可以是算数表达式,也可以是字符串常量、常数等。
如果是字符串常亮则输出字符串。

#### 选择表中的若干元组
也就是决定输出哪些行(元组)

##### 消除取值重复的行
```sql
SELECT DISTINCE ...
```

##### 查询满足条件的元组
通过指定`WHERE`子句实现

常用的查询条件:
|查询条件|谓词|
|-|-|
|比较|=,>,<,>=,<=,!=,<>,!>,!<; NOT+上述比较运算符|
|确定范围|BETWEEN AND,NOT BETWEEN AND|
|确定集合|IN, NOT ,IN|
|字符匹配|LIKE,NOT LIKE|
|空值|IS NULL,IS NOT NULL|
|多重条件(逻辑运算)|AND ,OR,NOT|


`<>`也是不等于的意思。

确定集合:查询计算机系(CS),数学系(MA)的学生的姓名和性别。
```sql
SELECT Sname,Ssex
FROM Student
WHERE Sdept IN ('CS','MA');
```

###### 字符串匹配
```sql
[NOT] LIKE '<匹配串>' [ESCAPE '<换码字符>']
```

字符匹配的通配符:
`%`:代表任意长度(长度可以为0)的字符串。
`_`:代表任意单个字符。
例子:查询学号为 201215121 的学生的详细情况
```sql
ELSECT *
FROM Student
WHERE Sno LIKE '201215121';
```
注意:
1. 这里是`WHERE`语句等价于`WHERE Sno = '201215121'` ,
因为后面没有`%`,所以不是查询所有 以 `201215121` 开头的学生。

2. 数据库字符集为 ASCII 时,一个汉字需要二个`_`;当字符集为 GBK 时只需要一个。


转义字符(换码字符):当需要输入 `_` 或者 `%` 这些统配字符的时候,需要转移,转移的标记不是固定的,需要自己指出
例子:查询 DB_Design 课程的课程号和学分
```
SELECT Cno,Credit
FROM Course
WHERE Cname LIKE 'DB\_Design' ESCAPE '\'
```

这里的`\`表示换码字符,这样紧跟在`\`后面的字符`_`就不具备通配符含义,同事如果要输出`\`,那么就需要输入`\\`

#### 聚集函数
常见的聚集函数:

|`COUNT(*)`|统计元组的个数|
|-|-|
|`COUNT([DISTINT\ALL] <列名>)`|统计一列|
|`SUM( [DISTINT\ALL] <列名> )`|统计一列值得综合(此列必须是数值型)|
|`AVG( [DISTINT\ALL] <列名> )`|统计一列值的平均值(此列必须是数值型)|
|`MAX( [DISTINT\ALL] <列名> )`|求一列值中的最大值|
|`MIN( [DISTINT\ALL] <列名> )`|求一列值中的最小值|

如果指定了 `DISTINT` 短语,则表示在计算时要取消指定列中的重复值。
如果不指定 `DISTINT` 或者指定 `ALL` 短语( `ALL` 为默认值),则表示不取消重复值。

当聚集函数遇到空值时,除`COUNT(*)`外,都跳过空值而处理非空值。
因为`COUNT(*)`时对元组进行技术,某个元组的一个或者部分列取值为空不影响`COUNT`的统计结果。(或者说主键不为空,每个元组都可以相互区分。)

例子:计算选修1号课程的学生的平均分
```sql
SELECT AVG(Grade)
FROM SC
WHERE Cno='1';
```

####  ORDER BY 子句
用户可以用`ORDER BY <列名> [ASC|DESC]`子句对查询结果按照一个或者多个属性列的升序(`ASC`)或者降序(`DESC`)排列,默认值为升序。

例子:查询选修了3号课程的学生的学号及其成绩,查询结果按分数的降序排列。
```sql
SELECT Sno,Grade
FROM SC
WHERE Cno = '3'
ORDER BY Grade DESC;
```

#### GROUP BY 子句
```sql
GROUP BY <列名[,列名,...]> [HAVING <条件>]
```
`GROUD BY`子句将查询结果按照某一列或多列的值分组,值相等的为一组。
例子:求各个课程号及相应的选课人数
```sql
SELECT Cno,COUNT(Sno)
FROM SC
GROUP BY Cno;
```

如果分组之后,还要按一定的条件对这些组进行筛选,最终只输出满足指定条件,则需要使用`HAVING` 短语进行筛选。
例子:查询选修了三门以上课程的学生学号。
```sql
SELECT Sno
FROM SC
GROUP BY Sno HAVING COUNT(*)>3;
  /*按学号分组,得到一个学生的选课,再对这个组进行计数*/
```

`WHERE`和`HAVING` 语句的区别在于作用对象不同。
`WHERE` 子句多用于基本表或试图,从中选择满足条件的元组。
`HAVING` 短语作用于组,从中选择满足条件的组。

### 连接查询
连接查询:简单地说就是连接表然后查询,实际上就是从多个表中选择各自的若干的属性出来,整合成一个新的表。

为区分不同表中相同属性名的属性列,则通过`表名.属性名`的方式来表示一个属性列。
当然,如果属性名是唯一的,那么可以省略表名前缀直接写

例子:查询每个学生及其选课情况
```sql
SELECT Student.*,SC.*
FROM Student,SC
WHERE Student.Sno = SC.sno;
```

自然连接:对于重复的列,只输出其中一个,就为自然连接
```sql
SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade
  /*sno有两个,一个是Student.Sno,一个是SC.Sno,如果只输出其中一个列,就是自然连接*/
FROM Student,SC
WHere Student.Sno = SC.sno;
```

#### 自身连接
例子:查询每一门课的间接先修课(即先修课的先修课)。
```sql
SELECT First.Cno,SECOND.Cpno
FROM Course FIRST,Courst SECONDE
    /*也就是通过别名在逻辑上划分成两个表,FROM 子句后面就当两个表写,但是要加上别名*/
WHERE FIRST.Cpno=SECOND.Cno;
```

#### 外连接
例子:查询每个学生及其选课情况
前面的代码是把所有选课的学生都列出来了,
但是如果是所有学生的选课情况,那么还要把没选课的学生列出来。
换言之,就是需要吧`Student`中的悬浮元组也列出来,也就是左外连接。
```sql
SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade
FROM Student LEFT OUTER JOIN SC ON (Student.Sno=SC.Sno)
```

#### 多表连接
例子:查询每个学生的学号、姓名、选修课的课程及成绩。
```sql
SELECT Student.Sno,Sname,Cname,Grade
FROM Student,SC,Course
WHERE Student.Sno=SC.Sno AND SC.Cno = Course.Cno;
```

### 嵌套查询
#### 不相关子查询
子查询的查询条件不依赖于父查询,称为 **不相关子查询**

#### 相关子查询
如果子查询的查询条件依赖于福查询,这类子查询称为 **相关子查询** ,整个查询语句称为 **相关嵌套查询**

例子:找出每个学生超过他自己选修课平均成绩的课程号。
```sql
SELECT Cno
FROM SC x
WHERE Grade > (
  SELECT AVG(Grade)
  FROM SC y
  WHERE x.Sno = y.Sno  );
    /*求这个学生选修的某个选修课的平均成绩,在和这个学生这门课的成绩比较。*/
```

#### ANY (或 SOME) 、 ALL 谓词与聚集函数,IN谓词的等价关系
||`=`|`<>`或`!=`|`<`|`<=`|`>`|`>=`|
|-|-|-|-|-|-|-|
|`ANY`|`IN`|--|`<MAX`|`<=MAX`|`>MIN`|`>=MIN`|
|`ALL`|--|`NOT IN`|`<MIN`|`<=MIN`|`>MAX`|`>=MAX`|

#### 带有 `EXISTS` 谓词的子查询
带有 `EXISTS`  谓词的子查询不反悔任何数据,只产生逻辑真值`true` 或 逻辑假值 `fasle`

例子:查询所有选修了1号课程的学生姓名
`EXISTS`实现:
```sql
SELECT Sname
FROM Student
WHERE EXISTS (
  SELECT *
  FROM SC
  WHERE Sno=Student.Sno AND Cno = 'A');
  /*由EXISTS引出的子查询,其目标列表达式通常都用**/
```
连接运算实现:
```sql
SELECT Sname
FROM Student ,SC
WHERE Student.Sno = SC.Sno AND Cno = 'a';
```

`EXISTS`谓词相对应的是`NOT EXISTS`谓词。

一些带有`EXISTS`或`NOT EXISTS`谓词的子查询不能被其他形式的子查询等价替换。
但带有`IN`谓词,比较运算符,`ANY`和`ALL`谓词的子查询都能用带有`EXISTS`谓词的子查询等价替换。

由于带`EXISTS`量词的相关子查询只关心内层查询效率是有返回值,并不需要查具体值,因此其效率并不一定低于不相关子查询,有时是搞笑的方法。

### 集合查询
集合操作主要包括:并操作`UNION`、交操作`INTERSET`、差操作`EXCEPT`

注意:参加集合操作的各查询的结果的列数必须相同;对应项数据类型也必须相同。

### 基于派生表的查询
子查询不仅可以出现在`WHERE`子句中,还可以出现在`FROM`子句中,这时子查询生成的`临时派生表 derived table`成为主查询的对象。

例子:查询所有选修了1号课程的学生姓名
```sql
SELECT Sname
FROM Student,(SELECT Sno FROM SC WHERE Cno='a') AS SC1
    /*AS 关键字可以省略,但必须给派生关系指定一个别名*/
WHERE Student.Sno=SC1.Sno;
```

## 数据更新

### 插入数据
#### 插入元组
```sql
INSERT
INTO <表名> [(属性列1,[,<属性列2>,...])]
VALUES (<常量1>,[,<常量2>,...])
```

例子:将一个新学生元组(学号:201215128,姓名:陈东,性别:男,所在系:IS,年龄:18) 插入到Student表中 。
```sql
INSERT
INTO Student(Sno,Sname,Ssex,Sdept,Sage)
VALUES ('201215128','陈东','男','IS',18);
```

#### 修改数据
```sql
UPDATE <表名>
SET <列名>=<表达式> [,<列名>=<表达式>,...]
[WHERE <条件>];
```

### 删除数据
```sql
DELETE
FROM <表名>
[WHERE <条件>];
```

## 空值处理
空值时`不知道`或`不存在`或`无意义`的值。
* 该属性应该是一个值,但目前不知道它的具体值。
* 该属性不应该有值。
* 由于某种原因不便于填写。

空值的判断:用`IS NULL` 或 `IS NOT NULL` 来表示 不能用 `= NULL`

空值的约束条件:
1. 属性定义(或者域定义)中有 `NOT NULL`的约束条件的不能取空值。
2. 加了 `UNIQUE` 限制的属性不能取空值。
3. 码属性不能取空值。

空值的算数运算、比较运算河逻辑运算
* 空值与另一个值(包括空值)的算数运算的结果为空值
* 空值与另一个值(包括空值)的比较运算的结果为 `UNKNOWN`
    有了`UNKNOWN`后,传统的逻辑运算中,二值(`TRUE`和`FALSE`)逻辑就扩展成了三值逻辑。

## 视图
视图的用途:
1. 限制数据访问
2. 能够简化用户的操作，使复杂查询简单化
3. 使用户能以多种角度看待同一数据
4. 对重构数据库提供了一定程度的逻辑独立性
5. 对机密数据提供安全保护

视图可以看做是子查询,把`SELECT`的结果保存起来,方便下次查询

问：为什么创建视图中不能在子查询中使用 `order by`?
1. 为了遵循 `ANSI-92` 标准?
2. 视图可以看做是子查询,其结果是一个集合,与顺序无关。只有在查询的时候指定顺序才有意义。
3. 其次,在查询视图的时候,可以指定`order by`来排序,如果视图本身包含了`order by`显然会冲突。

# 查询优化
代数优化和物理优化
1. 选择运算尽可能先做
		目的:减少中间关系

2. 在执行连接操作前,对关系进行适当的预处理
		- 在连接属性进行排序
		- 在连接属性上建立索引

3. 投影运算和选择运行同时做
		目的:避免重复扫描关系

4. 将投影运算与其前面或后面的双目运算结合
		目的:减少扫描关系的遍数

物理优化:底层操作实现的优化

# 数据库恢复技术
数据库随时都可能发生故障,会导致数据不完全,因此需要数据恢复
比如,突然断电,录入操作中断,导致数据的不完全

数据保护的类型:
1. 安全性
2. 完整性
3. 并发控制
4. 数据库恢复

事务:用户定义个一个数据库操作序列,这些操作序列要么全都完成,要么全都不完成

显式定义:
```
BEGIN TRANSACTION
	SEL语句s
COMMIT/ROOLBACK
```

数据的特性:(ACID特性)
1. 原子性
		事务不可拆分
2. 一致性
		使数据库从一个一致性状态转移到另一个一致性状态
		一致性状态:数据库中只包含提交成功的结果
3. 隔离性
		一个事务的执行,不会被其他事务干扰,并发并不影响事务的执行

4. 持续性
		一个事务,一旦提交成功,它对数据库的改变应该是永久性的

并发:应该是指同时进行同一种操作,但是这种操作的对象不相同(如果相同,这些相同对象的同种指令只能是串行执行)

## 故障的种类
### 事务内部故障
某种事务再运行过程中,由于种种原因未正常运行到终止点就夭折。
关键字:一个事务

原因可以为:
1. 输入数据有误
2. 运算溢出
3. 违反某些完整性限制
4. 某些应用程序出错
5. 并行事务发生死锁

恢复操作:
撤销事务(UNDO),强行回滚到事务发生之前的状态
消除事务对数据的所有修改,使得这个事务像没发生过一样

### 系统故障
整个系统的正常运行突然被破坏,但外部存储设备上的数据未受影响。比如断电
关键字:多个事务

恢复有两种情况:
1. 事务未完成被终端
		(UNDO)消除未完成的事务对数据库的修改

2. 事务已完成,但还在缓存中,未写入到数据库中
		(REDO)将缓冲区中已完成的提交,重新运行写入到数据库中

### 介质故障
使存储在外存中的数据全部或部分丢失。

比如:
1. 磁盘损坏
2. 磁头碰撞
3. 操作系统的某种潜在错误
4. 瞬时强电场干扰

恢复:装入数据库发生故障前的数据库的某个副本(也就是使用备份)
如果日志文件还没丢失,则在恢复备份之后,使用日志文件进行备份日期后面事务的redo

### 计算机病毒
应对方法:防火墙

## 数据库恢复操作
恢复操作的基本原理:冗余
通过冗余的数据来进行数据的恢复

如何建立冗余的数据?>
- 数据备份
- 日志文件

如何利用这些冗余的数据实施恢复?
1. 恢复备份
2. 重新运行事务

备份的分类
1. 静态备份和动态备份
		是否停止工作来进行备份,在备份结束之后再进行恢复

2. 海量备份和增量备份
		海量备份指完全备份
		增量备份指指保存变化的部分

上面两种方法两两组合就可产生4种备份的策略。

登记日志文件的格式:
1. 日志文件的格式
2. 日志文件内容
		- ...
		- 有关事务的内部操作,如触发器也要记录

问题:日志文件彭航地特别快,怎么缩小日志文件?

[3]:assets/数据库-90249.png
[2]:assets/数据库-cc73d.png
[1]:assets/数据库-a04c5.png
