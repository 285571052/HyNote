\documentclass[UTF8,a4paper]{ctexart}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr,hyperref}
\pagestyle{fancy}
\hypersetup{hidelinks}

\lhead{\bfseries \leftmark}
\chead{}
\rhead{SCUT}
\lfoot{\url{https://github.com/285571052}}
\cfoot{qhy}
\rfoot{\thepage}
\setlength{\headheight}{13pt}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\setlength{\parindent}{0pt}
\newcommand{\spaceline}{\vspace{\baselineskip}}

\author{ qhy }
\date{\today}
\title{人工智能}

\begin{document}
  \maketitle
  \tableofcontents
  \newpage

  \section{介绍}
  1956年提出人工智能的概念。

  \section{无题}
  \textbf{对于非结构化问题,即不能使用数学来进行描述的问题,我们怎么使用计算机进行描述?}\\
  使用\textbf{状态空间法:}
  \begin{itemize}
    \item 使用多元组来描述问题的状态
    \item 每个问题有初始态和目标抬
    \item 有些状态是非法的
    \item 我们需要做的是,从初始态转移到目标态
  \end{itemize}

  \begin{itemize}
    \item A算法与A*算法的区别
    \item A*算法的证明
    \item 爬山算法
  \end{itemize}

  % 人工智能第一章自习记录
  状态空间的搜索方式:
  \begin{itemize}
    \item 盲目搜索
    \item 启发式搜索
  \end{itemize}

  回溯搜索:不断扩展路径,直到终点或死路\\
  存在的问题:
  \begin{itemize}
    \item 深度问题\\
    搜索的深度过深(出现爆栈等问题)\\
    解决办法:对深度加以限制
    \item 死循环问题\\
    寻路过程可能陷入循环之中\\
    解决办法:记录从初始状态到当前状态的路径
  \end{itemize}

  回溯搜索:只保留从初始状态到当前状态的一条路径\\
  图搜索:保留所有已经搜索过的路径

  无信息图搜索过程:
  \begin{itemize}
    \item dfs\\
    不保证有解\\
    深度限制不合理,可能找不到解(可以将算法改为可变深度限制,比如迭代加深?)\\
    最坏情况等于穷举\\
    \item bfs\\
    当图有解时,一定能找到最优解\\
    效率低
  \end{itemize}

  启发式图搜索:引入启发只是,在保证找到最佳解的情况下,进可能减少搜索范围,提高搜索效率\\
  定义一个评价函数f,对当前搜搜状态进行评估,找出最有希望的节点来扩展

  A算法:$f(n) = g(n) , h(n)$\\
  其中,$g(n)$为评价函数,$h(n)$为启发函数

  定义$g^*(n)$为从s到n的最短路径的耗散值,$h^*(n)$为从n到g的最短路径的耗散值,$f^*(n) = g^*(n) + h^*(n)$为从s经过n到g的最短路径的耗散值\\
  $g(n) , h(n) , f(n)$是对三者的估计

  爬山法(局部搜索算法):$f(n) = h(n)$(只考虑还需要的最少耗散)

  分支限界法:如果对于任何的n,$f(n) = g(n) , h(n) = 0$(只考虑当前的最少耗散)

  动态规划算法:当$h(n) = 0$时,对于某个中间节点l,只考虑,s到l的最短路径分支,而不考虑其他

  最佳图搜索算法:A*算法,在A算法中,如果满足$h(n) \leq h^*(n)$,则称A算法为A*算法(也就是放宽了约束条件)

  对h的评价方法:
  \begin{itemize}
    \item 平均分叉树{有个奇怪的计算公式,后面再看}
  \end{itemize}

  A*算法的改进:可能会出现在求最优解的时候多次重复扩展同一个节点的情况,因为扩展的时候,并不是找到从初始节点到当前节点的最短路径(相当于枚举了所有的路径){改进之后的,才是我学的那个A*算法,设置上界,不满足上界的不要}
  解决办法:
  \begin{itemize}
    \item 对h加以限制,使得第一次扩展一个节点的时候,就找到了从s到当前节点的最短路径\\
    也就是选择节点的时候,选择到当前节点开销最小的节点
    \item 对算法加以改进,改进算法,避免多次扩展\\
    记录一个预测上界,如果比这个上界还大的节点,不再加入open 表
  \end{itemize}

  {回去再看,A算法到底怎么利用这个评估函数的?A算法,扩展节点的选择依赖f(n) , A*算法改进的,节点的选择依赖g(n)
  A算法保留了每个节点的上界,超过就不再加入open表?
  A算法是不是找最优解?与或图搜索与A*算法类似,只不过要考虑多个节点,并且每次只是扩展一个节点
  }

  % 第二章 与或图搜索问题
  与或图搜索问题:有些问题的解不移动是路径,而是子图,节点与其后续节点存在与关系,也存在或关系,这类图称为与或图
  即,搜索的过程,不一定走一个分支,可能需要同时满足两个分支都能达到终态

  博弈树搜索:
  \begin{itemize}
    \item 双人
    \item 一人一步
    \item 双方信息完备
    \item 零和{?????????}
  \end{itemize}

  极大极小过程中,棋局评价函数的特点:
  \begin{itemize}
    \item 先生成局部格局,再对格局进行评估
    \item 两个过程分开进行
    \item 效率低
  \end{itemize}

  $\alpha \beta$剪枝:
  \begin{itemize}
    \item 极大节点的下界为$\alpha$
    \item 极小节点的上界为$\beta$
    \item 剪枝条件:
      \begin{itemize}
        \item $\alpha$剪枝:后辈节点的$\beta$值$\leq$祖先节点的$\alpha$值
        \item $\beta$剪枝:后辈节点的$\alpha$值$\geq$祖先节点的$\beta$值
      \end{itemize}
    \item 简记:
      \begin{itemize}
        \item 极小$\leq$极大
        \item 极大$\geq$极小
      \end{itemize}
  \end{itemize}


% 第三章 归结推理方法
\textbf{命题:}能判断真假的陈述句。

\textbf{子句集:}合取范式形式下的子命题(元素)的集合

\textbf{归结法:}消除互补对,求新句子,得到归结式(证明命题用)

\textbf{归结过程:}
\begin{itemize}
  \item 将命题写成合取范式
  \item 求出子句集
  \item 对子句集使用归结推理规则
  \item 归结式作为新子句参加归结
  \item 归结式为空子句,S是不可满足的(矛盾),原命题成立。
\end{itemize}

\textbf{谓词归结:}\\
\textbf{前束范式:}一切量词都在公式的最左边(不含否定词),且这些量词的管辖域都延伸到公式的末端\\
\textbf{Skolem标准形}:前束范式消去量词之后的谓词公式????????

\textbf{求子句集:}
\begin{itemize}
  \item 求出Skolem标准形
  \item 消去存在变量
  \item 使用,代替合取符号,并表示成集合形式
\end{itemize}

\textbf{归结原理:}\\
\textbf{置换:}使用置换项去置换变量\\
置换的合成\\
合一:寻找相对变量的置换,使两个谓词公式一致

归结过程的策略控制:

\textbf{Herbrand定理:}公式G永真

/************************/
\textbf{知识的表示方法:}3元组,(对象,属性,值),(关系,对象1,对象2)

产生式规则:A$\to$B,一般A为因,B为果

\textbf{推理方法:}
\begin{itemize}
  \item 正向推理方法
  \item 反向推理方法
  \item 双向推理方法
  \item 与或树\\
  主要用于产生式规则的可视化
  \item 语义网络表示法\\
  表达实体内部组成部分(槽)的关系
\end{itemize}

可能的关系:类属关系,时间顺序关系

推理方法:
\begin{itemize}
  \item 网络匹配
  \item 继承关系
  \item 语义网络的推理
\end{itemize}

框架表示法:表达自己与组成部分的关系

\end{document}
