<!--toc-->

- [计算机系统组成](#计算机系统组成)
	- [计算机体系结构](#计算机体系结构)
		- [冯诺依曼体系结构](#冯诺依曼体系结构)
	- [计算机性能指标](#计算机性能指标)
- [什么时候用Byte ，什么时候用bit？](#什么时候用byte-什么时候用bit)
- [数据与文字的表示方法](#数据与文字的表示方法)
	- [原码表示法](#原码表示法)
	- [补码表示法](#补码表示法)
	- [反码](#反码)
	- [移码](#移码)
	- [对于n+1位的机器数X，所能表示的范围](#对于n1位的机器数x所能表示的范围)
- [浮点机器数](#浮点机器数)
	- [通用标准](#通用标准)
	- [IEEE754标准](#ieee754标准)
- [检验码](#检验码)
	- [奇偶校验码](#奇偶校验码)
- [定点数的加减法运算及其实现](#定点数的加减法运算及其实现)
	- [补码的加减运算](#补码的加减运算)
	- [二进制串行加减法运算器](#二进制串行加减法运算器)
- [机器数的位移运算](#机器数的位移运算)
- [定点数的乘法运算及实现](#定点数的乘法运算及实现)
	- [原码移位乘法](#原码移位乘法)
	- [阵列乘法器](#阵列乘法器)
		- [求补电路](#求补电路)
- [除法运算](#除法运算)
	- [原码恢复余数](#原码恢复余数)
	- [原码不恢复余数](#原码不恢复余数)
- [定点运算器](#定点运算器)
- [浮点运算及运算器](#浮点运算及运算器)
	- [浮点加/减运算](#浮点加减运算)
	- [小结](#小结)
- [存储系统](#存储系统)

<!-- tocstop -->
# 计算机系统组成
数据流是双向的，指令流是单向的

## 计算机体系结构

### 冯诺依曼体系结构
计算机体系结构-计算机组成-计算机实现 三者的关系是 表现-构成-实现

## 计算机性能指标
0. 时钟周期/主频
$T = \frac{1}{f}$

1. CPU执行时间
表示CPU执行一般程序所需要的时间
CPU执行时间 = CPU始终周期 × CPU时钟周期数

2. CPI
表示每条指令执行所需要的平均周期数

3. MIPS
表示1s内执行多少百万条定点指令

4. FLOPS
表示每秒执行浮点操作的次数。

# 什么时候用Byte ，什么时候用bit？
Byte：通过系统总线访问(System Bus)，即一次访问就能访问一个Byte
bit:串行存储器等，即每次访问都是xxbit，（比如U盘，网线）

# 数据与文字的表示方法
机器数：计算机内部编码表示的数。
真值：是指机器数所表示的真正的数

机器数的编码方法：原码，反码，移码，补码
PS：原码不是真值。

小数的表示方法：定点小数，浮点小数
定点小数，小数点的位置是固定的（定点小数 < 1?）
浮点小数：小数点的位置由阶数决定。

## 原码表示法
最高位为符号位。
符号位：0-正数，1-负数
数值为：和真值的绝对值相同

## 补码表示法
任意一个数的补码，等于它加上它的模数（再取模）
$[X]_{补} = X + M (MOD M)$ <!--_-->

1. 用n位二进制数表示整数补码(其中包括一个符号位)
    $[X]_{补}=\begin{cases}
    X &, X \geq 0 \\
    X + 2^n &, 2^n - 1 \leq X < 0
    \end{cases}$<!--_-->

2. 1. 用n位二进制数表示小数补码(其中包括一个符号位)
    $[X]_{补}=\begin{cases}
    X &,0 \leq X < 1 \\
    X + 2 &,  - 1 \leq X < 0
    \end{cases}$<!--_-->

表示方法：
最高位为符号位
符号位：0-正数，1-负数
数值位：正数时，和绝对值相同，负数时，绝对值取反后，末位+1


转换方法：
1. 补码 = 反码 + 1
2. 取最低为1的位，这一位以前的高位全部取反，这一位及其以后的低位保持不变。

## 反码
表示方法：
最高位为符号位
符号位：0-正数，1-负数
数值位：正数时，和绝对值相同，负数时，绝对值取反

## 移码
和补码类似，只不过符号位表示相反
符号位：0-负数，1-正数
相比补码的优势：这个机器数的大小关系就能表示真值的大小关系

## 对于n+1位的机器数X，所能表示的范围
1. 原码，反码
  $[-(2^n - 1), 2^n - 1]$
  $[-(1-2^{-n}),1-2^{-n}]$

2. 补码,移码
  $[-2^n, 2^n - 1]$
  $[-1,1-2^{-n}]$

小数的范围实际上就是整数的范围除以$2^n$


# 浮点机器数
## 通用标准
浮点数格式:
![1]
真值：$N = M×R^E$
底数R：默认底数 R = 2
$M = 0.M_1M_2M_3$
一般地，
1. 阶码用移码表示
2. 尾数用原码表示
3. 尾数的符号位（数符）放在最高位

规格化：
一般取 $\frac{1}{2} \leq |M| \leq 1$
则
真值一般表示成 $0.1xxxxx×2^E$ 的形式

## IEEE754标准
![2]
规格化尾数为 $M = 1.M_1M_2...$，即nbit的字段，可以存放表示成(n+1)bit的有效数字

其中,E的移码表示不再是移动 $2^{n - 1}$ 而是 $2^{n-1} - 1$，n为阶码的位数

![3]
特殊的浮点数：![4]

# 检验码
校验码的定义：是一种具有发现某些错误或自动改正错误能力的一种数据编码方法。

校验码的目的：用于检查或纠正在存取，读写和传输数据的过程中可能出现的错误。

## 奇偶校验码
有效信息位+1bit校验位=奇偶校验码
奇校验码：校验码中1的个数是奇数个（信息位偶数个加上校验位一个）
偶校验码：校验码中1个个数是偶数个

编码:$P_奇 = B_0 \oplus B_1 \oplus ... \oplus B_n$
译码：当译码结果E为的时候，无论奇偶，都表示数据正确、
$E = P_{奇/偶} \oplus B_0 \oplus b_1 \oplus .. \oplus b_n$

# 定点数的加减法运算及其实现
## 补码的加减运算
公式：
$[X + Y]_补 = [X]_补 + [Y]_补$
$[X - Y]_补 = [X]_补 + [-Y]_补$<!--_-->

1. 真值的减法 等价于加上一个负数
2. 补码可以直接相加减，得到的结果是真值运算结果的补码
3. 补码符号位的进位直接丢弃

溢出判断：
只有以下两种情况可能出现溢出现象：
1. 同号相加
2。 异号相减
![5]

实际上，异号详见也可以看成是同号相加。

判断方法有两种
1. 单符号位判断法：
		运算结果从机器数的角度来看，如果符号位不正确，那么说明发生了溢出

2. 双符号位判断法
		符号位扩展到两位，00表示正数，11表示负数，如果运算之后，符号位变成01，说明发生了正溢，10说明发生了负溢。
		这个也可以理解成，符号位和数值位分别运算，如果符号位和数值位产生的进位不同，那么就发生了溢出。
		但并不是说00和11就一定不会溢出了。

## 二进制串行加减法运算器

全加器逻辑表达式：由逻辑真值表可以轻易得到。
$S_i = A_i \oplus B_i \oplus C_i$
$C_{i+1} = A_iB_i + B_iC_i + C_iA_i = A_iB_i + (A_i\oplus B_i)C_i$
![6]

二进制串行加减法：
![7]
当M = 0为加法。
当M = 1为减法。
减法的过程实际上就是加上一个负数，这里实际上就是加上原来的数的补码，异或门是取反操作，第一个全加器进位有输入，表示末尾加1.

运算时间（延迟）：
T:单极逻辑门的延迟时间
那么进位$C_i$产生的时间为：2T
异或门由3个逻辑门组成，
那么$F_i$产生的时间为:$3\times 3T$
因此总时间$t = n\times 2T + 9T$

为什么$F_i$的时间不用乘以n，我们可以这样考虑
先执行所有进位之后，才进行数值位的运算。或者说 ，只有所有进位运算结束之后，$F_i$的计算才能输出正确的结果。

# 机器数的位移运算
逻辑移位：符号位也参与移位
算数移位：符号位保持不变，其他移位。
循环移位：所有的数据位在自身范围内左移或右移。

补码的算数移位：
1. 左移
		当移出的位和符号位不一致的时候，发生溢出。

2. 右移
	低位直接移出，高位正数补0，负数补1，也就是高位补符号位。

# 定点数的乘法运算及实现
使用原码进行运算
符号位和数值位分别运算。
符号位$P_s = X_y \oplus Y_s$
数值位:$|P| = |X| \times |Y|$

乘法的机器算法：从乘数的最低位开始，每次根据乘数位得到其位积，乘数位为0，位积为0，乘数位为1，则位积为被乘数；用原部分积右移1位加上本次位积，得新部分积；初始部分积为0。
![8]

## 原码移位乘法
原码移位乘法：电路结构简单，但是速度慢

## 阵列乘法器
![9]

1. 计算器中数值以补码的形式存储，那么在运算之前，需要对数值位进行转换
		![10]
2. 符号位单独运算
3. 最后结果再转换成补码

实际上，具体的计算过程和我们手写的是一样的。

### 求补电路
求补码的电路（准确的说，是取反码再加一，可以实现补码和原码的互相转换）
![11]
当E=0的时候，不求补
当E=1的时候，求补（其实就是符号位输入）

# 除法运算

## 原码恢复余数
二进制除法中，商只能是0和1，原码恢复余数，就是每次都上1，然后如果余数为负数，那么就改商为0，余数恢复成原来那个。
求余数的过程，实际上就是减去余数，进一步来看，就是加上 负余数的补码
恢复余数，实际上就是加回除数。
例子：
X=+0.1011
Y= -0.1101
用原码恢复余数算法计算X÷Y

解:
[X]原=0.1011    
[Y]原=1.1101  
|X|=0.1011     
|Y|=0.1101    
[-|Y|]补=11.0011
QS = XS ⊕YS = 1   RS = 0
![12]
得：
[Q]原=1.1101    
[R]原=0.00000111


## 原码不恢复余数
加减交替法的规则如下：
1. 余数为正时，商上1，求下一位商的办法，是余数左移一位，再减去除数；
2. 当余数为负时，商上0，求下一位商的办法，是余数左移一位，再加上除数。
3. 若最后一次上商为0，而又需得到正确余数，则在这最后一次仍需恢复余数。

也就是说，如果商0，那么下一步余数就加上被除数

![14]
![15]

阵列除法器
![13]

# 定点运算器
$C_1 = Y_0 + X_0C_0$
$C_2 = Y_1 + X_1C_1 = Y_1 + X_1X_0 + X_1X_0C_0$
第一个等式后面为串行实现电路的原理，
第二个等式后面为并行实现电路的原理。

并行实际上为串行的展开式，它不需要等待上一级的结果，而是直接由输入进行计算获得。
也就是说并行电路是以更多的运算器（阵列）为代价来提高运算速度的。

$C_{n+4} = G + PC_n$
G:进位发生输出
P:进位传送输出
$G = Y_3 + Y_2Y_3 + Y_1Y_2Y_3 + Y_0Y_1Y_2Y_3C_n$
$P = X_0X_1X_2X_3$

$X_i$ ， $Y_i$ 和控制参数和输入量的关系如下图：
图图。。。。。。。。。。。

则
$X_i = \overline{S_2}\overline{S_3} + \overline{S_2}S(\overline{A_i} + \overline{B_i}) + S_2S_3\overline{A_i}$
$Y_i = \overline{S_0}\overline{S_1}\overline{A_i} + \overline{S_0}\overline{S_1}B_i + s_0\overline{S_1}\overline{A_i}\overline{B_i}$

正逻辑和负逻辑的概念:

若多个74181先行进位器同时使用，那么整个电路本质上还是串行电路。
这个时候需要对输出进一步进行并行运算。也就是74182


32bit并行加法器需要多少个181和182？
181的话，每4bit需要一个，共需要8个
182也是4输入，则需要（2 + 1） = 3个
```{mermaid}
graph TD
B_1(181) --> A1(182)
B_2(181) --> A1
B_3(181) --> A1
B_4(181) --> A1

B_5(181) --> A2(182)
B_6(181) --> A2
B_7(181) --> A2
B_8(181) --> A2

A1 --> A3(182)
A2 --> A3(182)
```

定点运算器的组成：
某个图./...........

寄存器传输快，但是功耗大，因此在CPU中寄存器的数量不多（还要考虑到发热的问题呢）

总线：能为多个功能部件传输信息的一组传输线。
总线同时只能有一个部件占用，否则多个部件占用，如果一个部件输出1，一个部件输出0，那么两端就会形成电势差，而中间的电阻为0，显然会出事。

通过三态门来实现对总线的占用。

# 浮点运算及运算器
## 浮点加/减运算
基本思想是把两个数的阶码调节成一样的，然后尾数直接进行相加减。阶码由小的向大的看齐。
1. 0操作数检查
		如果有操作数为0，那么就无需进行后续的步骤，尽可能地简化步骤
2. 阶码调节成一样(小阶向大阶看齐)
		1. 阶码求差，得到$\Delta E$
		2. $\Delta E > 0$，则$M_Y$不断右移
		3. $\Delta E < 0$，则$M_X$不断右移
		4. 不断右移直到$\Delta E = 0$
3. 尾数相加减
4. 加减后的结果还需要进行规格化（这里以双符号位补码为例）
		1. 两符号位相异，右一次
		2. 如果符号位和尾数最高位符号相同（也就是小数点前后的数字不同），则不断左规，知道相异
		3. 每规一次，阶码也要作出对应的变化。

5. 舍入
	（有以下几种选择，包括但不限于，并且发生在右规的时候）
		1. 0舍1入
		2. 直接舍弃
		3. 最后一位直接置1
		这个可以减少误差，但会增加运算次数，耗时。

6. 阶码判断溢

## 小结
浮点数加减法：
乘法：尾数相乘，阶码相加
除法：尾数相除，阶码相减

如果使用移码表示，双符号法判断溢出的时候，恒0用参加加减运算，也就是第一个符号位为0表示没溢出。

流水线，加速比，表示生产相同数目的时间的比值

# 存储系统
各种分类：。。。。

[15]:assets/计算机组成-28974.png
[14]:assets/计算机组成-a40fb.png
[13]:assets/计算机组成-83880.png
[12]:assets/计算机组成-c8cc9.png
[11]:assets/计算机组成-a2a1f.png
[10]:assets/计算机组成-e6859.png
[9]:assets/计算机组成-7f0fd.png
[8]:assets/计算机组成-0c1cd.png
[7]:assets/计算机组成-98b0b.png
[6]:assets/计算机组成-1b3e7.png
[5]:assets/计算机组成-0acb3.png
[4]:assets/计算机组成-263eb.png
[3]:assets/计算机组成-bb6cf.png
[2]:assets/计算机组成-986a3.png
[1]:assets/计算机组成-fe2fb.png
