<!--toc-->

- [计算机系统组成](#计算机系统组成)
	- [计算机体系结构](#计算机体系结构)
		- [冯诺依曼体系结构](#冯诺依曼体系结构)
	- [计算机性能指标](#计算机性能指标)
- [什么时候用Byte ，什么时候用bit？](#什么时候用byte-什么时候用bit)
- [数据与文字的表示方法](#数据与文字的表示方法)
	- [原码表示法](#原码表示法)
	- [补码表示法](#补码表示法)
	- [反码](#反码)
	- [移码](#移码)
	- [对于n+1位的机器数X，所能表示的范围](#对于n1位的机器数x所能表示的范围)
- [浮点机器数](#浮点机器数)
	- [通用标准](#通用标准)
	- [IEEE754标准](#ieee754标准)
- [检验码](#检验码)
	- [奇偶校验码](#奇偶校验码)
- [定点数的加减法运算及其实现](#定点数的加减法运算及其实现)
	- [补码的加减运算](#补码的加减运算)
	- [二进制串行加减法运算器](#二进制串行加减法运算器)
- [机器数的位移运算](#机器数的位移运算)
- [定点数的乘法运算及实现](#定点数的乘法运算及实现)
	- [原码移位乘法](#原码移位乘法)
	- [阵列乘法器](#阵列乘法器)
		- [求补电路](#求补电路)
- [除法运算](#除法运算)
	- [原码恢复余数](#原码恢复余数)
	- [原码不恢复余数](#原码不恢复余数)
- [定点运算器](#定点运算器)
- [浮点运算及运算器](#浮点运算及运算器)
	- [浮点加/减运算](#浮点加减运算)
	- [小结](#小结)
- [存储系统](#存储系统)
	- [存储器的分类](#存储器的分类)
		- [按存储介质分类](#按存储介质分类)
		- [按存取方式分类](#按存取方式分类)
		- [按存储器的读写功能分类](#按存储器的读写功能分类)
		- [按信息的可保存性分类](#按信息的可保存性分类)
		- [按在计算机系统中的作用分类](#按在计算机系统中的作用分类)
	- [主存储器](#主存储器)
		- [主存储器的分类](#主存储器的分类)
		- [主存储器的性能指标](#主存储器的性能指标)
			- [存储容量](#存储容量)
			- [存储速度](#存储速度)
			- [存储器的价格](#存储器的价格)
			- [可靠性](#可靠性)
			- [功耗](#功耗)
			- [存储容量、速度、价格的关系](#存储容量-速度-价格的关系)
		- [随机读写存储器 RAM](#随机读写存储器-ram)
			- [静态存储器 SRAM](#静态存储器-sram)
				- [单向译码](#单向译码)
				- [双向译码](#双向译码)
				- [基本的SRAM逻辑结构](#基本的sram逻辑结构)
			- [动态存储器 DRAM](#动态存储器-dram)
				- [DRAM的刷新方式](#dram的刷新方式)
					- [集中式刷新](#集中式刷新)
					- [分散式刷新](#分散式刷新)
					- [异步式刷新](#异步式刷新)
				- [DRAM主存读/写正确性校验](#dram主存读写正确性校验)
			- [SRAM 和 DRAM 的对比](#sram-和-dram-的对比)
			- [高性能存储器](#高性能存储器)
				- [FPM RAM](#fpm-ram)
				- [CDRAM](#cdram)
		- [只读存储器](#只读存储器)
			- [MROM 掩膜式只读存储器](#mrom-掩膜式只读存储器)
			- [PROM 可编程只读存储器](#prom-可编程只读存储器)
			- [EPROM](#eprom)
			- [FLASH 存储元](#flash-存储元)
			- [集中非易失性存储器的比较](#集中非易失性存储器的比较)
	- [DRAM](#dram)
- [cache](#cache)
	- [cache 映射方法](#cache-映射方法)
	- [chche 替换算法](#chche-替换算法)
	- [cache 操作策略](#cache-操作策略)
	- [cache 多层次设计](#cache-多层次设计)
- [虚拟存储器的工作过程](#虚拟存储器的工作过程)
	- [管理方式](#管理方式)
- [指令系统](#指令系统)
	- [指令的寻址方式](#指令的寻址方式)
		- [直接寻址](#直接寻址)
		- [间接寻址](#间接寻址)
		- [寄存器寻址](#寄存器寻址)
		- [寄存器间接寻址](#寄存器间接寻址)
		- [偏移寻址](#偏移寻址)
		- [段寻址](#段寻址)
		- [堆栈寻址](#堆栈寻址)
	- [8bit字长的指令系统设计](#8bit字长的指令系统设计)
		- [一般指令格式](#一般指令格式)
		- [格式2](#格式2)
		- [格式3:三字格式](#格式3三字格式)
		- [扩展指令格式](#扩展指令格式)

<!-- tocstop -->
# 计算机系统组成
数据流是双向的，指令流是单向的

## 计算机体系结构

### 冯诺依曼体系结构
计算机体系结构-计算机组成-计算机实现 三者的关系是 表现-构成-实现

## 计算机性能指标
0. 时钟周期/主频
$T = \frac{1}{f}$

1. CPU执行时间
表示CPU执行一般程序所需要的时间
CPU执行时间 = CPU始终周期 × CPU时钟周期数

2. CPI
表示每条指令执行所需要的平均周期数

3. MIPS
表示1s内执行多少百万条定点指令

4. FLOPS
表示每秒执行浮点操作的次数。

# 什么时候用Byte ，什么时候用bit？
Byte：通过系统总线访问(System Bus)，即一次访问就能访问一个Byte
bit:串行存储器等，即每次访问都是xxbit，（比如U盘，网线）

# 数据与文字的表示方法
机器数：计算机内部编码表示的数。
真值：是指机器数所表示的真正的数

机器数的编码方法：原码，反码，移码，补码
PS：原码不是真值。

小数的表示方法：定点小数，浮点小数
定点小数，小数点的位置是固定的（定点小数 < 1?）
浮点小数：小数点的位置由阶数决定。

## 原码表示法
最高位为符号位。
符号位：0-正数，1-负数
数值为：和真值的绝对值相同

## 补码表示法
任意一个数的补码，等于它加上它的模数（再取模）
$[X]_{补} = X + M (MOD M)$ <!--_-->

1. 用n位二进制数表示整数补码(其中包括一个符号位)
    $[X]_{补}=\begin{cases}
    X &, X \geq 0 \\
    X + 2^n &, 2^n - 1 \leq X < 0
    \end{cases}$<!--_-->

2. 1. 用n位二进制数表示小数补码(其中包括一个符号位)
    $[X]_{补}=\begin{cases}
    X &,0 \leq X < 1 \\
    X + 2 &,  - 1 \leq X < 0
    \end{cases}$<!--_-->

表示方法：
最高位为符号位
符号位：0-正数，1-负数
数值位：正数时，和绝对值相同，负数时，绝对值取反后，末位+1


转换方法：
1. 补码 = 反码 + 1
2. 取最低为1的位，这一位以前的高位全部取反，这一位及其以后的低位保持不变。

## 反码
表示方法：
最高位为符号位
符号位：0-正数，1-负数
数值位：正数时，和绝对值相同，负数时，绝对值取反

## 移码
和补码类似，只不过符号位表示相反
符号位：0-负数，1-正数
相比补码的优势：这个机器数的大小关系就能表示真值的大小关系

## 对于n+1位的机器数X，所能表示的范围
1. 原码，反码
  $[-(2^n - 1), 2^n - 1]$
  $[-(1-2^{-n}),1-2^{-n}]$

2. 补码,移码
  $[-2^n, 2^n - 1]$
  $[-1,1-2^{-n}]$

小数的范围实际上就是整数的范围除以$2^n$


# 浮点机器数
## 通用标准
浮点数格式:
![1]
真值：$N = M×R^E$
底数R：默认底数 R = 2
$M = 0.M_1M_2M_3$
一般地，
1. 阶码用移码表示
2. 尾数用原码表示
3. 尾数的符号位（数符）放在最高位

规格化：
一般取 $\frac{1}{2} \leq |M| \leq 1$
则
真值一般表示成 $0.1xxxxx×2^E$ 的形式

## IEEE754标准
![2]
规格化尾数为 $M = 1.M_1M_2...$，即nbit的字段，可以存放表示成(n+1)bit的有效数字

其中,E的移码表示不再是移动 $2^{n - 1}$ 而是 $2^{n-1} - 1$，n为阶码的位数

![3]
特殊的浮点数：![4]

# 检验码
校验码的定义：是一种具有发现某些错误或自动改正错误能力的一种数据编码方法。

校验码的目的：用于检查或纠正在存取，读写和传输数据的过程中可能出现的错误。

## 奇偶校验码
有效信息位+1bit校验位=奇偶校验码
奇校验码：校验码中1的个数是奇数个（信息位偶数个加上校验位一个）
偶校验码：校验码中1个个数是偶数个

编码:$P_奇 = B_0 \oplus B_1 \oplus ... \oplus B_n$
译码：当译码结果E为的时候，无论奇偶，都表示数据正确、
$E = P_{奇/偶} \oplus B_0 \oplus b_1 \oplus .. \oplus b_n$

# 定点数的加减法运算及其实现
## 补码的加减运算
公式：
$[X + Y]_补 = [X]_补 + [Y]_补$
$[X - Y]_补 = [X]_补 + [-Y]_补$<!--_-->

1. 真值的减法 等价于加上一个负数
2. 补码可以直接相加减，得到的结果是真值运算结果的补码
3. 补码符号位的进位直接丢弃

溢出判断：
只有以下两种情况可能出现溢出现象：
1. 同号相加
2。 异号相减
![5]

实际上，异号详见也可以看成是同号相加。

判断方法有两种
1. 单符号位判断法：
		运算结果从机器数的角度来看，如果符号位不正确，那么说明发生了溢出

2. 双符号位判断法
		符号位扩展到两位，00表示正数，11表示负数，如果运算之后，符号位变成01，说明发生了正溢，10说明发生了负溢。
		这个也可以理解成，符号位和数值位分别运算，如果符号位和数值位产生的进位不同，那么就发生了溢出。
		但并不是说00和11就一定不会溢出了。

## 二进制串行加减法运算器

全加器逻辑表达式：由逻辑真值表可以轻易得到。
$S_i = A_i \oplus B_i \oplus C_i$
$C_{i+1} = A_iB_i + B_iC_i + C_iA_i = A_iB_i + (A_i\oplus B_i)C_i$
![6]

二进制串行加减法：
![7]
当M = 0为加法。
当M = 1为减法。
减法的过程实际上就是加上一个负数，这里实际上就是加上原来的数的补码，异或门是取反操作，第一个全加器进位有输入，表示末尾加1.

运算时间（延迟）：
T:单极逻辑门的延迟时间
那么进位$C_i$产生的时间为：2T
异或门由3个逻辑门组成，
那么$F_i$产生的时间为:$3\times 3T$
因此总时间$t = n\times 2T + 9T$

为什么$F_i$的时间不用乘以n，我们可以这样考虑
先执行所有进位之后，才进行数值位的运算。或者说 ，只有所有进位运算结束之后，$F_i$的计算才能输出正确的结果。

# 机器数的位移运算
逻辑移位：符号位也参与移位
算数移位：符号位保持不变，其他移位。
循环移位：所有的数据位在自身范围内左移或右移。

补码的算数移位：
1. 左移
		当移出的位和符号位不一致的时候，发生溢出。

2. 右移
	低位直接移出，高位正数补0，负数补1，也就是高位补符号位。

# 定点数的乘法运算及实现
使用原码进行运算
符号位和数值位分别运算。
符号位$P_s = X_y \oplus Y_s$
数值位:$|P| = |X| \times |Y|$

乘法的机器算法：从乘数的最低位开始，每次根据乘数位得到其位积，乘数位为0，位积为0，乘数位为1，则位积为被乘数；用原部分积右移1位加上本次位积，得新部分积；初始部分积为0。
![8]

## 原码移位乘法
原码移位乘法：电路结构简单，但是速度慢

## 阵列乘法器
![9]

1. 计算器中数值以补码的形式存储，那么在运算之前，需要对数值位进行转换
		![10]
2. 符号位单独运算
3. 最后结果再转换成补码

实际上，具体的计算过程和我们手写的是一样的。

### 求补电路
求补码的电路（准确的说，是取反码再加一，可以实现补码和原码的互相转换）
![11]
当E=0的时候，不求补
当E=1的时候，求补（其实就是符号位输入）

# 除法运算

## 原码恢复余数
二进制除法中，商只能是0和1，原码恢复余数，就是每次都上1，然后如果余数为负数，那么就改商为0，余数恢复成原来那个。
求余数的过程，实际上就是减去余数，进一步来看，就是加上 负余数的补码
恢复余数，实际上就是加回除数。
例子：
X=+0.1011
Y= -0.1101
用原码恢复余数算法计算X÷Y

解:
[X]原=0.1011    
[Y]原=1.1101  
|X|=0.1011     
|Y|=0.1101    
[-|Y|]补=11.0011
QS = XS ⊕YS = 1   RS = 0
![12]
得：
[Q]原=1.1101    
[R]原=0.00000111


## 原码不恢复余数
加减交替法的规则如下：
1. 余数为正时，商上1，求下一位商的办法，是余数左移一位，再减去除数；
2. 当余数为负时，商上0，求下一位商的办法，是余数左移一位，再加上除数。
3. 若最后一次上商为0，而又需得到正确余数，则在这最后一次仍需恢复余数。

也就是说，如果商0，那么下一步余数就加上被除数

![14]
![15]

阵列除法器
![13]

# 定点运算器
$C_1 = Y_0 + X_0C_0$
$C_2 = Y_1 + X_1C_1 = Y_1 + X_1X_0 + X_1X_0C_0$
第一个等式后面为串行实现电路的原理，
第二个等式后面为并行实现电路的原理。

并行实际上为串行的展开式，它不需要等待上一级的结果，而是直接由输入进行计算获得。
也就是说并行电路是以更多的运算器（阵列）为代价来提高运算速度的。

$C_{n+4} = G + PC_n$
G:进位发生输出
P:进位传送输出
$G = Y_3 + Y_2Y_3 + Y_1Y_2Y_3 + Y_0Y_1Y_2Y_3C_n$
$P = X_0X_1X_2X_3$

$X_i$ ， $Y_i$ 和控制参数和输入量的关系如下图：
图图。。。。。。。。。。。

则
$X_i = \overline{S_2}\overline{S_3} + \overline{S_2}S(\overline{A_i} + \overline{B_i}) + S_2S_3\overline{A_i}$
$Y_i = \overline{S_0}\overline{S_1}\overline{A_i} + \overline{S_0}\overline{S_1}B_i + s_0\overline{S_1}\overline{A_i}\overline{B_i}$

正逻辑和负逻辑的概念:

若多个74181先行进位器同时使用，那么整个电路本质上还是串行电路。
这个时候需要对输出进一步进行并行运算。也就是74182


32bit并行加法器需要多少个181和182？
181的话，每4bit需要一个，共需要8个
182也是4输入，则需要（2 + 1） = 3个
```{mermaid}
graph TD
B_1(181) --> A1(182)
B_2(181) --> A1
B_3(181) --> A1
B_4(181) --> A1

B_5(181) --> A2(182)
B_6(181) --> A2
B_7(181) --> A2
B_8(181) --> A2

A1 --> A3(182)
A2 --> A3(182)
```

定点运算器的组成：
某个图./...........

寄存器传输快，但是功耗大，因此在CPU中寄存器的数量不多（还要考虑到发热的问题呢）

总线：能为多个功能部件传输信息的一组传输线。
总线同时只能有一个部件占用，否则多个部件占用，如果一个部件输出1，一个部件输出0，那么两端就会形成电势差，而中间的电阻为0，显然会出事。

通过三态门来实现对总线的占用。

# 浮点运算及运算器
## 浮点加/减运算
基本思想是把两个数的阶码调节成一样的，然后尾数直接进行相加减。阶码由小的向大的看齐。
1. 0操作数检查
		如果有操作数为0，那么就无需进行后续的步骤，尽可能地简化步骤
2. 阶码调节成一样(小阶向大阶看齐)
		1. 阶码求差，得到$\Delta E$
		2. $\Delta E > 0$，则$M_Y$不断右移
		3. $\Delta E < 0$，则$M_X$不断右移
		4. 不断右移直到$\Delta E = 0$
3. 尾数相加减
4. 加减后的结果还需要进行规格化（这里以双符号位补码为例）
		1. 两符号位相异，右一次
		2. 如果符号位和尾数最高位符号相同（也就是小数点前后的数字不同），则不断左规，知道相异
		3. 每规一次，阶码也要作出对应的变化。

5. 舍入
	（有以下几种选择，包括但不限于，并且发生在右规的时候）
		1. 0舍1入
		2. 直接舍弃
		3. 最后一位直接置1
		这个可以减少误差，但会增加运算次数，耗时。

6. 阶码判断溢

## 小结
浮点数加减法：
乘法：尾数相乘，阶码相加
除法：尾数相除，阶码相减

如果使用移码表示，双符号法判断溢出的时候，恒0用参加加减运算，也就是第一个符号位为0表示没溢出。

流水线，加速比，表示生产相同数目的时间的比值

# 存储系统
## 存储器的分类
### 按存储介质分类
1. 半导体器件
		用作主存,如:RAM,ROM
2. 磁性材料
		用作辅存,如:磁盘
3. 光介质
		用作辅存,如:光盘

### 按存取方式分类
1. 随机存储器
		存储器中任何存储单元的内容都能被随机存取,且存取时间和存取单元的物理位置无关。(主存)
2. 顺序存储器
		存取时间和存储单元的物理位置有关(磁盘、磁带)

### 按存储器的读写功能分类
1. 只读存储器 ROM Read-Only-Memory
2. 读写存储器 RAM Random-Access-Memory
		一般隐含指随机存取

### 按信息的可保存性分类
1. 永久记忆的存储器
		又成非易失性存储器,断电后还能保存信息(辅存,ROM)

2. 非永久性记忆的存储器
		又称易失性存储器,在断电后信息丢失(主存中的RAM)

### 按在计算机系统中的作用分类
1. 主存储器
		又称内存,为主机的一部分,用于存放系统当前在执行的数据和程序,属于临时存储器

2. 辅助存储器
		又称外存,为外部设备,用于存放暂不用的数据和程序,属于永久存储器

## 主存储器
特点:
1. 主存储器可以被CPU直接存取(访问)。
2. 一般由半导体材质构成
3. 随机存取
		读写任意存储单元所需的时间是相同的,与单元地址无关
4. 与辅存相比,速度快,价格高,容量小

主存储器按照其功能可分为:RAM和ROM
1. 随机读写存储器 RAM
2. 只读存储器 ROM
3. 高性能主存储器

### 主存储器的分类
主存的地位:在现代计算机中,主存储器处于全机的中心地位。

主存的要求为:随机存取,快速

主存的分类:
1. 随机读写存储器RAM
2. 只读存储器 ROM
		1. 掩膜式只读存储器 MROM
		2. 可编程只读存储器 PROM
		3. 可擦除可编程的只读存储器 EPROM
		4. 电可查出的可编程的只读存储器 E^2^PROM
3.  闪存 Flash memory
		字节编程类似于 E^2^PROM,但擦除必须以块、页、整片方式擦除,写入速度比E^2^PROM高10^3^数量级以上


计算机中的存储器分类:
$\begin{cases}
主存储器\begin{cases}
RAM\begin{cases}
SRAM &,Cache\\
DRAM
\end{cases}\\\\
ROM\begin{cases}
MROM \\
PROM \\
EPROM\\
E^2PROM
\end{cases}\\\\
FLASH
\end{cases}\\\\\\
辅助存储器\begin{cases}
磁盘 \begin{cases}
软盘\\
硬盘
\end{cases}\\
磁带 \\
光盘\begin{cases}
CD-ROM\\
WORM\\
EOD
\end{cases} \\
\end{cases}
\end{cases}$

### 主存储器的性能指标
#### 存储容量
指存储器可容纳的二进制信息量,描述存储容量的单位是字节或位

#### 存储速度
由一下三个方法来衡量
1. 存取时间 memory Access Time
		指启动一次存储器操作到完成该操作所需的全部时间。存取时间越短,其性能越好。
		通常存取时间用纳秒为单位

2. 存储周期 Memory Cycle Time
		指存储器进行连续两次独立的存储操作所需的最小时间间隔。
		通常存取周期T~C~大于存取时间T~A~, $T_C \geq T_A$

3. 存储器带宽
		是单位时间内存储器所能存取的最大信息量,存储器带宽的计算单位通常是 位/秒 (bps) 或 字节/秒,它是衡量数据传输速率的重要技术指标。

#### 存储器的价格
用每位的价格来衡量,它不仅包含了存储元件的价格,还包括为该存储器操作服务的外围设备的价格。

#### 可靠性
指存储器正常工具(正确存储区)的性能。

#### 功耗
存储器工作的耗电量。

#### 存储容量、速度、价格的关系
1. 速度快的存储器往往价格较高,容量也较小
2. 容量、速度和价格三个指标是互相制约的。


### 随机读写存储器 RAM
![16]
#### 静态存储器 SRAM
##### 单向译码
![17]
地址译码的方式:
1. 一维译码方式
		nbit地址线,经过一维译码之后,有2^n^根选择线
		每根选择线对应一个存储单元,一个存储单元为一个字,有若干个bit

2. 单向译码方式

优点:结构简单
缺点:当芯片容量增大时,译码器的复杂性按指数规律增加。

因此,一维地址译码适合容量小的场合。

##### 双向译码
![18]
双向译码方式:
n bit地址分为行、列地址分别译码

可以证明:
若地址码为n bit,当$\frac{n}{2}$位正整数时,$n_x = n_y = \frac{n}{2}$时,译码器及输出驱动线数最简单。

优点:地址译码器的结构简单,节省驱动器和译码线。
缺点:同一存储单元的各二进制单元分布在不同的芯片上,即每个存储芯片只能提供该单元的一个二进制位。

##### 基本的SRAM逻辑结构
![19]

CS:片选信号
OE:读出使能信号
WE:写入使能信号
OE和WE同时只能有一个有效

SRAM存储器的特点:
1. 使用双稳态触发器表示0和1代码
2. 电源不掉电的情况下,信息稳定保持(静态)
3. 存取速度快,集成度低(容量小),价格高
4. 常用作高速缓冲存储器的Cache

#### 动态存储器 DRAM
DRAM使用电容作为存储位源,电容上有电荷表示1,没有电荷表示0
再生:读出后信息可能被破坏,需要重写
刷新:经过一段时间后,信息可能丢失,需要重写

DRAM存储器的基本结构(4M×4bit的DRAM):
![20]

DRAM存储器的特点:
1. 使用半导体器件中分布电容有无电荷来表示0和1代码
2. 电源不掉电的情况下,信息也会丢失,因此需要不断刷新
3. 存取速度慢(电容充放电需要时间),集成度高(容量大),价格低
4. 常用作内存条

##### DRAM的刷新方式
刷新周期:从上一次刷新结束到下一次对整个DRAM全部刷新为止,这一段时
间间隔成为刷新周期。

刷新操作:
即是 按行来执行内部的读操作(读的时候相当于刷新了)。
由刷新计数器产生行地址,选择当前要刷新的行,读即刷新。
刷新一行所需时间即是一个存储周期(读一行的时间就是存储周期)。

刷新行数:
单个芯片的单个矩阵的行数。
1. 对于内部包含多个存储矩阵的芯片,各个矩阵的同一行是被同时刷新的。
2. 对于多个芯片连接构成的DRAM,DRAM控制器将选中所有芯片的同一行来进行逐行刷新。

单元刷新时间间隔:
DRAM允许的最大信心保持时间,一般为2ms

刷新方式:
1. 集中式刷新
2. 分散式刷新
3. 异步式刷新

###### 集中式刷新
![21]
在单元刷新时间间隔(2ms)内,集中对所有行刷新一遍,其余时间则用于访问操作。

在内部刷新的时间内,不允许访存,这段时间呗成为死时间。

集中式刷新的死时间过长,往往不能接受。

###### 分散式刷新
![22]
在任何一个存储周期内,分为访存和刷新两个子周期。
在访存时间,供CPU和其他主设备访问。
在刷新时间内,对DRAM的某一行刷新。
(前部分时间用来访存,后一部分时间指令执行,这一段时间用来刷新,因此也有一定的合理性)

存储周期为存储器存储周期的两倍(意思是两个子周期相同?)

使用这个方法,要求刷新所有行的时间必须要小于单元刷新间隔时间

这种方法,往往在单元时间间隔内就刷新了很多遍,这实际上是一种浪费。

###### 异步式刷新
![23]
异步式刷新采用折中的方法,把2ms(单元刷新时间间隔)分散地把各行刷新一遍。
这样就避免了分散式刷新中不必要的多次刷新,提高了整机速度,同是又解决了集中式刷新"死区"时间过长的问题。

##### DRAM主存读/写正确性校验
DRAM通常用作主存储器,其读写操作的正确性与可靠性至关重要。
为此除了正常的数据位宽度,还增加了附加位,用于读/写操作正确性的校验。
增加的附加位也要同数据位一起写入DRAM中保存。

#### SRAM 和 DRAM 的对比
![24]

#### 高性能存储器
FPM RAM:快速页模式动态存储器
CDRAM:带Cache的DRAM
SDRAM(Synchronous Dynamic RAM):也称同步DRAM
DDR SDRAM:双倍率SDRAM,简称DDR

##### FPM RAM
FPM RAM:快速页模式动态存储器
根据程序的局部性原理来实现,
页是指一个唯一的行地址和该行中所有的列地址确定的存储单元总和。

快速页模式:允许在选定的行中对该行的每一列进行连续的读/写操作

##### CDRAM
CDRAM:带告诉缓冲存储器(Cache)的动态存储器,在通常的DRAM芯片内又集成了一个小容量的SRAM,从而使DRAM芯片的性能得到显著改进

### 只读存储器
![25]


ROM的种类:
1. MROM
2. PROM
3. EPROM
4. E^2^PROM
5. Flash Memory

#### MROM 掩膜式只读存储器
MROM 掩膜式只读存储器(Mashed ROM)
存储信息是由生产厂家在掩膜工艺过程中"写入",用户不能修改

优点:可靠性高,集成度高,适宜大批量生产,价格便宜

#### PROM 可编程只读存储器
PROM(Programmable ROM):一次性编程的只读存储器
编程写入:芯片出厂时所有位均为0,用户可用编程器将要写入位的熔丝熔断,即可写入1

#### EPROM
EPROM:光可擦除可编程只读存储器
存储原理:浮栅有/无积存电子,则管子有/无导电勾到,所在位为0/1

#### FLASH 存储元
FLASH存储器也翻译成闪速存储器，它是高密度非失易失性的读/写存储器。高密度意味着它具有巨大比特数目的存储容量。非易失性意味着存放的数据在没有电源的情况下可以长期保存。总之，它既有RAM的优点，又有ROM的优点，称得上是存储技术划时代的进展。

读操作时，在某一时间只有一条行选择线被激活。

假定某个存储元原存1，那么晶体管导通，与它所在位线接通，有电流通过位线，所经过的负载上产生一个电压降。这个电压降送到比较器的一个输入端，与另一端输入的参照电压做比较，比较器输出一个标志为逻辑1的电平。

如果某个存储元原先存0，那么晶体管不导通，位线上没有电流，比较器输出端则产生一个标志为逻辑0的电平。

#### 集中非易失性存储器的比较
![26]

## 存储器容量扩展的三种方法
### 位扩展
位扩展:从字长方向扩展,从下图来看,就是叠多几层
![27]

要点:
1. 芯片的地址线A、读写控制信号WE# , 片选信号CS# 分别连接到新的芯片上
2. 芯片的数据线D分别对应所搭建的存储器的高若干位

### 字扩展
从字数方向扩展,总的来看,就是扩展了整个存储器的容量
![28]

要点:
1. 合成的新的存储器的高若干位经过译码器,用作各芯片的片选信号CS#
2. 芯片的数据线D,读写控制信号WE#,分别连到芯片的对应位置
3. 存储器地址线A的低若干位连接各芯片的地址线

### 字位扩展
从字长和字数方向扩展或者低若干位(一次读取的字的bit数变大,因此数据线的数目要增加)

也就是上面两种方法的结合。

需要扩展你的存储器容量为M×Nbit,已有的芯片容量为L×Kbit,(L<M,K<N),则需要的芯片的数目为:$\frac{M  \times N}{L \times K}$
也就是容量的比值
其中,用$\frac{M}{L}$组芯片进行字扩展
每组内有$\frac{N}{K}$个芯片进行位扩展

## 主存储器和CPU的连接
主存和CPU的连接：通过三总线连接



<!--未整理-->

# cache
## cache 映射方法
1. 全相联映射
		内存可以映射到cache中的任何位置

2. 直接映射
		多对一映射,一个内存块可以映射到cache的特定行
		(类似hash)

		- 内存和cache的描述
		内存:
		|标记|字块地址|块内地址|
		|-|-|-|

		cache存储域:
		|标记|块内容|
		|-|-|

4. 组相连映射:
		前面两种映射方法的结合,以若干个内存块映射到指定的行,但是内存块内可以随机映射

## chche 替换算法
1. 随机替换算法
2. 先进先出替换算法
3. 最近最少使用算法

## cache 操作策略
1. 当ceche被替换出去时,才同步被修改的主存块
		这个方法存在主存和cache不一致的隐患

2. 全写法
		同步修改

3. 写一次法
		前面两种策略的结果
		当首次写cache命中才同时写入主存,访问之后都采用第一种方法

## cache 多层次设计
1. 统一cache 和 分离 cache
		分类原因:指令和数据是否混放

2. 单级cache 和 二级cache
		cache速度逐层递减,但还是比主存快
		一级cache离CPU最近,且最快,但是容量小,远离的容量大,但是速度慢

# 虚拟存储器的工作过程
虚拟存储器由操作系统软硬件实现。

## 管理方式
1. 按段行管理
		段与段的大小可以不一样

2. 按页管理
		页与页的大小一样

3. 段页式
		前面两种策略的结合,先段,段内使用页管理

1. 使用快表加快虚、实地址的变换
		为避免对主存访问次数的增多,可以对页表本身实行2级缓存,即CPU中的页表是快表

2. 帧页表
		记录当前主存的使用情况

3. 帧页表的桥梁作用
		调*:辅存$\to$主存,填帧页表
		调出:主存$\to$赋存,置修改位为1 为1

4. 页面替换算法

# 指令系统
指令系统分类:
1. CISC 复杂指令系统
2. RISC 精简指令系统

两个系统的特点???????????????????
精简指令系统指令码定长。

性能要求:
1. 完备性
2. 有效性
3. 规整性
		- 对称性
		- 匀条性
		- 一致性

4. 兼容性
		主要是向上兼容(不是向下兼容),能在低档机上运行的程序,要求能在高档机上运行

执行基本格式:
|OP|A|
|-|-|
|操作码|地址码|

指令分类:
- 功能分类
		- 数据传送指令
		- 算数逻辑运算指令
		- 程序控制指令
		- 装配拆卸指令
		- I/O指令
		- 其他

操作码扩展技术:
以前k位为操作的代码,那么可以能$2^k - 1$个操作指令
k个1用来表示扩展,其后t位为新的操作码,能表示$2^t$个指令
以此类推


## 指令的寻址方式
### 直接寻址
直接访问数据,即操作数是数据的地址

### 间接寻址
间接访问数据,即操作数是数据的地址的地址

### 寄存器寻址
操作数是寄存器,寄存器存放的是数据

### 寄存器间接寻址
操作数是寄存器,集群次存放数据的地址

间接寻址的特点:能够扩展寻址的范围,
比如操作数只能用4bit表示,如果这4bit用来表示寄存器,而寄存器的表示可以是32bit,那么寻址的范围就不是4bit而是32bit

### 偏移寻址
类似间接寻址,只不过还有一个操作数是偏移量

1. 变址寻址
		```
		DATA = (EA)
		EA = (RI) + A
		```
		RI:变址寻址器
		A:偏移量
		(RI):基准地址

2. 基址寻址
		```
		DATA = (EA)
		EA = (Rb) + A
		```
		Rb:基址寻址器

3. 相对寻址
		相对于当前执行代码的行数的进行偏移
		```
		DATA = (EA)
		EA = (PC) + A
		```
		PC:程序计数器
		A:相对偏移量,DISP

1和2的区别:
1. 1在于实现程序的规律变化
2. 2可以扩大寻址范围

1,2,3的区别:
使用的寄存器不同

### 段寻址
主要针对x86的CPUI
将段寄存器的基地址左移4bit与16bit偏移量相加,形成20bit内存物理地址的寻址方式

### 堆栈寻址
操作数位于堆栈中,由堆栈指针寄存器SP隐含指出

地址扩展方式:
1. 低到高
2. 高地址向低地址扩展

```
PUSH Ri
(SP)-1 -> SP
(Ri) -> (SP)
```
```
POP Ri
(SP) -> (Ri)
(SP)+1 -> SP
```

## 8bit字长的指令系统设计
主要包括:
1. 模型机指令格式
2. 模型机寻址方式
3. 模型机指令系统设计

指令格式:
### 一般指令格式
|OP|SR|DR|
|-|-|-|
|DATA/ADDR/DISP/X|

OP:操作码
SR:源寄存器
DE:目标寄存器
X:偏移地址

### 格式2
|OP|MOD|SR|DR|
|-|-|-|-|
|DATA/ADDR/DISP/X|

MOD:寻址方式

### 格式3:三字格式

|OP|SR|DR|
|-|-|-|
|ADDR/DISP/X|
|DATA/ADDR/DISP/X|

|OP|MOD|SR|DR|
|-|-|-|-|
|ADDR/DISP/X|
|DATA/ADDR/DISP/X|

### 扩展指令格式
??????????

[28]:assets/计算机组成-affbe.png
[27]:assets/计算机组成-9a688.png
[26]:assets/计算机组成-fda42.png
[25]:assets/计算机组成-f89fe.png
[24]:assets/计算机组成-5746a.png
[23]:assets/计算机组成-e5ac3.png
[22]:assets/计算机组成-02007.png
[21]:assets/计算机组成-dd966.png
[20]:assets/计算机组成-00b99.png
[19]:assets/计算机组成-d47e1.png
[18]:assets/计算机组成-8b4b6.png
[17]:assets/计算机组成-b4852.png
[16]:assets/计算机组成-7f98d.png
[15]:assets/计算机组成-28974.png
[14]:assets/计算机组成-a40fb.png
[13]:assets/计算机组成-83880.png
[12]:assets/计算机组成-c8cc9.png
[11]:assets/计算机组成-a2a1f.png
[10]:assets/计算机组成-e6859.png
[9]:assets/计算机组成-7f0fd.png
[8]:assets/计算机组成-0c1cd.png
[7]:assets/计算机组成-98b0b.png
[6]:assets/计算机组成-1b3e7.png
[5]:assets/计算机组成-0acb3.png
[4]:assets/计算机组成-263eb.png
[3]:assets/计算机组成-bb6cf.png
[2]:assets/计算机组成-986a3.png
[1]:assets/计算机组成-fe2fb.png
