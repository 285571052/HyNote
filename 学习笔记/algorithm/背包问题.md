# 01背包问题
有n个物品，第i个物品价值v\[i\]，体积为c\[i\]，把这n个物品放入一个容量为 V 的背包中，问最多能放多大价值的物品。

定义：$f(i,v)表示前i个物品，放入容量v的背包的最大值$
对于每个物品，有两个状态，一个是放一个是不放
因此$f(i,v) = max(f(i-1,v),f(i-1,v-c(i)) + v(i))$

为了确保只放了一次，f(i-1,v-c(i)) 必须是没有放的，所以，我们枚举v的时候，从大往小的方向枚举。

## 参考代码
```{cpp}
for(int i = 1; i <= n ; ++i){
  for(int j = c[i];j <= V;++j){
    f[i][j] = max(f[i - 1][j],f[i - 1][j - c[i]] + v[i]);
  }
}
```

## 空间优化
从上面代码可以看出，递推的更新只需要上一层的值。
如果我们从后面（`dp[i][V]`）开始更新值，那么所利用的值就是前面的值。因此`dp[i][V]`中的 `[i]` 就没必要使用。（具体见代码）

### 优化后代码
```{cpp}
for(int i = 1; i <= n ; ++i){
  for(int j = V;j j>= c[i];--j){
    f[j] = max(f[j],f[j - c[i]] + v[i]);
  }
}
```

## 其他
1. 实际上，递推公式的最后一层只需要计算最后一个值即可，因为这个值只和上一层有关。

2. 有一些值在求值的过程是不需要计算到的，所以使用递归的写法能减少一定的运算的代价，但同时递归也会带来一定的开销，所以也不知道哪个更好

# 完全背包
有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

定义：$f(i,v)表示前i个物品，放入容量v的背包的最大值$
对于每个物品，有两个状态，一个是放一个是不放
因此$f(i,v) = max(f(i-1,v),f(i-1,v-c(i)) + v(i))$

对于01背包问题
为了确保只放了一次，f(i-1,v-c(i)) 必须是没有放的，所以，我们枚举v的时候，从大往小的方向枚举。这样可以避免重复。

但是对于完全背包问题，我们不需要担心重复的问题，所以枚举v的时候，只需要从小往大枚举即可。

## 参考代码
```{cpp}
int dp[maxv],v[maxn],c[maxn];
for (int i = 0; i < n; ++i) {
  for (int j = c[i]; j <= m; ++j) {
    dp[j] = max(dp[j], dp[j - c[i]] + v[i]);
  }
}
int ans = -1;
for (int i = 0; i <= m; ++i) {
  ans = max(ans, dp[i]);
}
```
