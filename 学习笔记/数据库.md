# 学习目标
![1]

# 考核方式
![2]

# 如何提高水平
![3]

# 数据库
1. 数据
2. 数据库
  就是数据的集合
3. 数据库管理系统
  支持一下功能
    1. 数据的定义
    2. 数据的组织，存储，管理
    3. 数据的操纵
    4. 数据的建立和维护
    5. 数据的事务管理和运行管理
    6. 其他

人工管理的缺点：
1. 不保存
2. 直接通过应用程序管理数据
3. 不共享
4. 不独立

文件系统：
1. 长期保存
2。 由文件系统管理
3. 冗余度大
4. 独立性差

数据库：
1. 数据结构化
2. 共享性高， 冗余度低
3. 独立性强
4. 数据由数据库管理系统统一管理和控制

# 数据库的分类
非关系型模型:层次模型，网状模型，由于这两种模型难以表达数据，因此没有普及，也因此不讲

关系型模型:比前面两个模型更加简化的模型，又叫作 表，二维表，是当前(2017-3)主流的数据库模型

## 关系型模型
逻辑上，所有的数据由一个个表组成，但物理上还是基于文件系统的。

~~一个图~~

每一个实体由一行组成，每一行又叫做元组，或者记录
域:属性的取值范围
度不能太大

随着日志的规模越来越大，如果数据都放在一个表中，那么速度会越来越慢


问:主码和码的区别?
码:由实体间相互区分的属性构成，即码的值不可以重复，但是码可以有多个。也就是说只要属性值不重复的属性都可以称为码（名字如果没有重复的话，也可以是码）
主码:主码只能有一个，但是不是指一个属性，可以由多个属性联合表示，但是它必须可以唯一确定一个元组。

问:关系型数据无法处理表中嵌套表的表示，那这个情况要怎么表达？
上面的意思是，一个表中的属性不可以再次区分，（也就是属性不能是表），这个时候可以把表嵌套表的数据拆分成多个表来表示（也就是嵌套的表再次拆分出来）。

## 关系型数据的约束性
1. 实体完整性
2. 参照完整性
3. 用户定义的完整性

# 数据库系统的结构
0. 单用户数据系统
1. 主从式数据库系统

2. 分布式数据库系统
    主要是数据的同步和处理

3. C/S结构数据库
    比如，360的病毒库，手机app

4. B/S 服务器结构
    能简化应用操作的复杂性

5. 嵌入式数据库
    数据库的规模小

# 数据库的模式结构
三级模式结构
外模式:通过视图/应用该程序 来访问数据，对用户来说，这个是不透明的（也就是用户只关心拿到的数据，而不关心数据内部的结构）


# 关系代数
关系代数是一种抽象的查询语言，它同对关系的运算来表达查询。
关系袋鼠的运算按运算符的不同分为两种：
1. 传统的集合运算
    主要包括，并，交，差，笛卡儿积
2. 专门的关系运算

|集合运算符|含义|
|-|-|
|$\cup$|并|
|$\cap$|交|
|$-$|差|
|$\times$|笛卡儿积|

|关系运算符|含义|
|-|-|
|$\sigma$|选择|
|$\Pi$|投影|
|$\Join$|连接|
|$\div$|除|

## 关系运算
### 选择
选择：在关系R中选择满足给定条件F的诸元组（从行中选择行）
$\sigma_F(R)$

### 投影
投影：从关系R中选择若干属性组成新的关系（即从列中抽取列出来组成一个新的表）
注意：投影的结果是会去重复的。
比如，投影性别，结果是{男，女}，而不是{男，男，女，女}
$\Pi_A(R)$

### 连接
从两个关系的笛卡尔积中选择属性间满足一定关系的的元组。
$\begin{matrix}
R \Join S \\
\scriptsize{A  \Theta B}
\end{matrix}$

### 等值连接
$\begin{matrix}
R \Join S \\
\scriptsize{A  = B}
\end{matrix}$
表示从关系R和S的笛卡儿积中，选择A和B属性值相等的i那些元组。（A是R的属性，B是S的属性）

### 自然连接
自然连接是特殊的等值连接，它要求两个属性名必须相同。
取 等值连接的两个属性名相同的列出来 组成一个新的表。并且两个同名的属性，只保留一个下来。

### 外连接
在自然连接的时候，不存在属性值相等的元素，那么就会被丢弃。
被丢弃的元组称为悬浮元组。
如果保留这些悬浮元组。那么就称为外连接。
如果只保留左边关系R中的悬浮元组，称为左外连接
如果只保留右边关系S中的悬浮元组，称为右外连接

## 除
$R \div S = T$
结果T包含了在R但不在S中的属性及值，且T的元组与S的元组的所以组合都在R中。


# 自然连接
等值去重复，即同名属性列（公共属性列）去除重复的连接

# 索引建立的条件
？》？？？

# 结构化的查询语言 SQL语言
/********************************************/
结果来自同一个表，但是不是一次遍历得到的时候，应该使用更名运算，逻辑上把一个表看作两个表，理解成内容相同的两个表经过一次遍历得到结果（之所以是要更名，就是为了区别这两个逻辑上的表，否则表达式就有歧义了）
1. 创建表
```
CREATE TABLE XXX(
  XXX1 CHAR(8),
  XXX2 CHAR(2));
```

2. 插入命令
```
INSERT INTO XXX(XXX1,XXX2)
VALUES('12345678','12')
```

3. 查询
```
???
```

转义符号：？？？
空值判断：`IS NULL` 不能用 `= NULL`

结果排序: `ORDER BY 属性1，属性2  升/降序参数`
默认是是升序排序，参数分别为`ASC` 和 `DESC`

字符串函数：非SQL标准，看具体数据库的文档

多表连接运算：
```
SELECT table.colum1 ,table table colum2
FROM table1, table2
WHERE table1.colum1 = table2.colum2
```

别名：直接在表后面写上即可

连接类型：
1. Equijoin
2. Non-equjoin
3. outer-join
4. self join
    当出现需要多次查找自身的时候，就需要使用别名，也就是自连接

问：为什么视图中不能在子查询中使用 `order by`
0
/**************************************************************/
基本表是本身独立存在的表，在关系数据库管理系统中一个关系就对应一个基本表。一个或多个基本表对应一个存储文件，一个表可以带若干索引，索引也存放在存储文件中。

## 数据定义
一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表，试图，索引等数据对象

### 模式的定义和删除
#### 定义模式
```
CREATE SCHEMA <模式名> AUTHORIZATION <用户名>;
```

如果没有指定 `<模式名>`，那么 `<模式名>` 就隐含为 `<用户名>`

例子：为用户 `WANG` 定义一个学生-课程模式 S-T
```
CREATE SCHEMA "S-T" AUTHORIZATION WANG
```

#### 删除模式
```
DROP SCHEMA <模式名><CASCADE|RESTRICT>
```
`CASCADE`:级联，表示在删除模式的同时，把该模式中所有的数据库对象都删除。
`RESTRICT`:限制，表示如果该模式中已经定义了下属的数据库对象，则拒绝该删除语句的执行。

### 基本表的定义、删除、修改
#### 定义基本表
```
CREATE TABLE <表名> (<列名><数据库类型>[列级完整性约束条件]
[,<列名><数据库类型>[列级完整性约束条件]]
...
[<列名><数据库类型>[列级完整性约束条件]]);
```

例子:建立一个"学生"表 Student
```
CREATE TABLE Student
  (Sno CHAR(9) PRIMARYKEY;
  Sname CHAR(20) UNIQUE,
  Ssex CHAR(2),
  Sage SMALLINT,
  Sdept CHAR(20)
    );
```

`PRIMARYKEY`:表名 `Sno` 是主码
`UNIQUE`:表名 `Sname` 取唯一值

##### 数据类型
|数据类型|含义|
|-|-|
|CHAR(n),CHARACTER(n)|长度为n的定长字符串|
|VARCHAR(n),CHARACTERVARYING(n)|最大长度为n的变长字符串|
|CLOB|字符串大对象|
|BLOB|二进制大对象|
|INT,INTEGER|长整数(4字节)|
|SMALLINT|短整数(2字节)|
|BIGINT|大整数(8字节)|
|NUMERIC(p,d)|定点数,由p位数字(不包括符号,小数点)组成,小数点后面有d位数字|
|DECIMAL(p,d),DEC(p,d)|同NUMERIC|
|REAL|取决于机器精度的单精度浮点数|
|DOUBLE PRECISION|取决于机器精度的双精度浮点数|
|FLOAT(n)|可选择精度的浮点数,精度至少为n位数字|
|BOOLEAN|逻辑布尔量|
|DATE|日期,包含年、月、日,格式为YYYY-MM-DD|
|TIME|时间,包含一日的时、分、秒,格式为HH:MM:SS|
|TIMESTAMP|时间戳类型|
|INTERVAL|时间间隔类型|

#### 模式与表
每一个基本表都属于某个模式,一个模式包含多个基本表。
那怎么关联这个模式和表?有三种方法。
1. 在表名明显地给出模式名
    ```
    CREATE TABLE "S-T".Student(...); //Student 所属的模式是 S-T
    ```

2. 在创建模式的语句中同时创建表
    也就是创建模式的语句后面,紧跟创建表的语句。

3. 设置所属的模式,这样在创建表时表名不必给出模式名
    ```
    SET search TO "S-T",PUBLIC;
    CREATE TABLE Student(...);
    ```

#### 修改表
SQL语言用`ALTER TABLE` 语句来修改基本表。
```
ALTER TABLE <表名>
[ADD [COLUMN]  <新列名><数据类型> [完整性约束]]
[ADD <表级完整性约束>]
[DROP [COLUMN] <列名> [CASCADE|RESTRICT]]
    /*CASCADE:自动删除引动该列的对象,RESTRICT:如果已经有引用,则拒绝删除*/
[DROP CONSTRAINT<完整性约束> [RESTRICT|CASCADE]]
    /*CONSTRAINT 用于删除指定的完整性约束条件*/
[ALTER COLUMN <列名><数据类型>]
    /*用于修改原有的列定义*/
    ```

#### 删除基本表
```
DROP TABLE <表名> [RESTRICT|CASCADE]
    /*默认是 RESTRICT*/
```
### 索引的建立与删除
一般说来,建立与删除索引由数据库管理员或表的 **属主**( **owner** ),即建立表的人,负责完成。
用户不必也不能显示地选择索引。
索引是关系型数据库管理系统的内部实现技术,属于内模式的范畴。

#### 建立索引
```
CREATE [UNIQUE] [CLUSTER] INDEX <索引名>
ON <表名>(<列名> [<次序>] [,<列名> [<次序>] ...]);
    /* 次序由两种选择:ASC:升序,DESC:降序
     * CLUSTER 表示要建立的索引是聚簇索引
     * UNIQUE 表明此索引的每一个索引值只对应唯一的数据记录
     */
```

#### 修改索引
```
ALTER INDEX <旧索引名> RENAME TO <新索引名>
```

#### 删除索引
```
DROP INDEX <索引名>
```

## 数据查询
```
SELECT [ALL|DISTINCE] <目标列表达式> [,<目标列表达式>] ***
FROM <表名或视图名> [,<表名或视图名>] | (<SELECT 语句>) [AS] <别名>
    /*别名的命名方式:在下一个列之前(逗号之前)加上 "[空格]别名"*/
[WHERE <条件表达式>]
    /*根据WHERE子句的条件表达式从FROM子句指定的基本表、视图或派生表中找出满足条件的元组,再按SELECT 子句的目标列表达式选出元组中的属性形成结果表*/
[GROUD BY <列名1> [HAVING <条件表达式>]]
    /* 将结果按<列名1>的值进行分组,该属性列值相等的元组为一个组。通常会再每组中作用聚集函数
     * HAVING 短语,只有满足制定条件的组才予以输出。 */
[ORDER BY <列名2> [ASC|DESC]];
```

### 单表查询
#### 选择表中的若干列
也就是决定输出哪些列(属性)
##### 查询指定列
    查询全体学生的学号与姓名
    ```
    SELECT Sno,Sname
    FROM Student;
    ```

#####  查询全部列
    即以 `*` 号省略列名的书写
    查询全体学生的详细信息
    ```
    SELECT *
    FROM Student;
    ```

#####  查询经过计算的值
    查询全体学生的姓名及其出生年份(只知道学生的年龄)
    ```
    SELECT Sname,2014-Sage
    FROM Student
    ```

    目标列不仅可以是算数表达式,也可以是字符串常量、常数等。
    如果是字符串常亮则输出字符串。

#### 选择表中的若干元组
也就是决定输出哪些行(元组)
##### 消除取值重复的行
```
SELECT DISTINCE ...
```

##### 查询满足条件的元组
通过指定`WHERE`子句实现

常用的查询条件:
|查询条件|谓词|
|-|-|
|比较|=,>,<,>=,<=,!=,<>,!>,!<; NOT+上述比较运算符|
|确定范围|BETWEEN AND,NOT BETWEEN AND|
|确定集合|IN, NOT ,IN|
|字符匹配|LIKE,NOT LIKE|
|空值|IS NULL,IS NOT NULL|
|多重条件(逻辑运算)|AND ,OR,NOT|


`<>`也是不等于的意思。

确定集合:查询计算机系(CS),数学系(MA)的学生的姓名和性别。
```
SELECT Sname,Ssex
FROM Student
WHERE Sdept IN ('CS','MA');
```

###### 字符串匹配
```
[NOT] LIKE '<匹配串>' [ESCAPE '<换码字符>']
```

字符匹配的通配符:
`%`:代表任意长度(长度可以为0)的字符串。
`_`:代表任意单个字符。
例子:查询学号为 201215121 的学生的详细情况
```
ELSECT *
FROM Student
WHERE Sno LIKE '201215121';
```
注意:
1. 这里是`WHERE`语句等价于`WHERE Sno = '201215121'` ,
因为后面没有`%`,所以不是查询所有 以 `201215121` 开头的学生。

2. 数据库字符集为 ASCII 时,一个汉字需要二个`_`;当字符集为 GBK 时只需要一个。


转义字符(换码字符):当需要输入 `_` 或者 `%` 这些统配字符的时候,需要转移,转移的标记不是固定的,需要自己指出
例子:查询 DB_Design 课程的课程号和学分
```
SELECT Cno,Credit
FROM Course
WHERE Cname LIKE 'DB\_Design' ESCAPE '\'
```
这里的`\`表示换码字符,这样紧跟在`\`后面的字符`_`就不具备通配符含义,同事如果要输出`\`,那么就需要输入`\\`

#### 聚集函数
常见的聚集函数:

|`COUNT(*)`|统计元组的个数|
|-|-|
|`COUNT([DISTINT|ALL] <列名>)`|统计一列|
|`SUM( [DISTINT|ALL] <列名> )`|统计一列值得综合(此列必须是数值型)|
|`AVG( [DISTINT|ALL] <列名> )`|统计一列值的平均值(此列必须是数值型)|
|`MAX( [DISTINT|ALL] <列名> )`|求一列值中的最大值|
|`MIN( [DISTINT|ALL] <列名> )`|求一列值中的最小值|

如果指定了 `DISTINT` 短语,则表示在计算时要取消指定列中的重复值。
如果不指定 `DISTINT` 或者指定 `ALL` 短语( `ALL` 为默认值),则表示不取消重复值。

当聚集函数遇到空值时,除`COUNT(*)`外,都跳过空值而处理非空值。
因为`COUNT(*)`时对元组进行技术,某个元组的一个或者部分列取值为空不影响`COUNT`的统计结果。(或者说主键不为空,每个元组都可以相互区分。)

例子:计算选修1号课程的学生的平均分
```
SELECT AVG(Grade)
FROM SC
WHERE Cno='1';
```

####  ORDER BY 子句
用户可以用`ORDER BY <列名> [ASC|DESC]`子句对查询结果按照一个或者多个属性列的升序(`ASC`)或者降序(`DESC`)排列,默认值为升序。

例子:查询选修了3号课程的学生的学号及其成绩,查询结果按分数的降序排列。
```
SELECT Sno,Grade
FROM SC
WHERE Cno = '3'
ORDER BY Grade DESC;
```

#### GROUP BY 子句
```
GROUP BY <列名[,列名,...]> [HAVING <条件>]
```
`GROUD BY`子句将查询结果按照某一列或多列的值分组,值相等的为一组。
例子:求各个课程号及相应的选课人数
```
SELECT Cno,COUNT(Sno)
FROM SC
GROUP BY Cno;
```

如果分组之后,还要按一定的条件对这些组进行筛选,最终只输出满足指定条件,则需要使用`HAVING` 短语进行筛选。
例子:查询选修了三门以上课程的学生学号。
```
SELECT Sno
FROM SC
GROUP BY Sno HAVING COUNT(*)>3;
  /*按学号分组,得到一个学生的选课,再对这个组进行计数*/
```

`WHERE`和`HAVING` 语句的区别在于作用对象不同。
`WHERE` 子句多用于基本表或试图,从中选择满足条件的元组。
`HAVING` 短语作用于组,从中选择满足条件的组。

### 连接查询
连接查询:简单地说就是连接表然后查询,实际上就是从多个表中选择各自的若干的属性出来,整合成一个新的表。

为区分不同表中相同属性名的属性列,则通过`表名.属性名`的方式来表示一个属性列。
当然,如果属性名是唯一的,那么可以省略表名前缀直接写

例子:查询每个学生及其选课情况
```
SELECT Student.*,SC.*
FROM Student,SC
WHERE Student.Sno = SC.sno;
```

自然连接:对于重复的列,只输出其中一个,就为自然连接
```
SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade
  /*sno有两个,一个是Student.Sno,一个是SC.Sno,如果只输出其中一个列,就是自然连接*/
FROM Student,SC
WHere Student.Sno = SC.sno;
```

#### 自身连接
例子:查询每一门课的间接先修课(即先修课的先修课)。
```
SELECT First.Cno,SECOND.Cpno
FROM Course FIRST,Courst SECONDE
    /*也就是通过别名在逻辑上划分成两个表,FROM 子句后面就当两个表写,但是要加上别名*/
WHERE FIRST.Cpno=SECOND.Cno;
```

#### 外连接
例子:查询每个学生及其选课情况
前面的代码是把所有选课的学生都列出来了,
但是如果是所有学生的选课情况,那么还要把没选课的学生列出来。
换言之,就是需要吧`Student`中的悬浮元组也列出来,也就是左外连接。
```
SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,Grade
FROM Student LEFT OUTER JOIN SC ON (Student.Sno=SC.Sno)
```

#### 多表连接
例子:查询每个学生的学号、姓名、选修课的课程及成绩。
```
SELECT Student.Sno,Sname,Cname,Grade
FROM Student,SC,Course
WHERE Student.Sno=SC.Sno AND SC.Cno = Course.Cno;
```

### 嵌套查询
#### 不相关子查询
子查询的查询条件不依赖于父查询,称为 **不相关子查询**

#### 相关子查询
如果子查询的查询条件依赖于福查询,这类子查询称为 **相关子查询** ,整个查询语句称为 **相关嵌套查询**

例子:找出每个学生超过他自己选修课平均成绩的课程号。
```
SELECT Cno
FROM SC x
WHERE Grade > (
  SELECT AVG(Grade)
  FROM SC y
  WHERE x.Sno = y.Sno  );
    /*求这个学生选修的某个选修课的平均成绩,在和这个学生这门课的成绩比较。*/
```

#### ANY (或 SOME) 、 ALL 谓词与聚集函数,IN谓词的等价关系
||`=`|`<>`或`!=`|`<`|`<=`|`>`|`>=`|
|-|-|-|-|-|-|-|-|
|`ANY`|`IN`|--|`<MAX`|`<=MAX`|`>MIN`|`>=MIN`|
|`ALL`|--|`NOT IN`|`<MIN`|`<=MIN`|'>MAX'|`>=MAX`|

#### 带有 `EXISTS` 谓词的子查询





[3]:assets/数据库-90249.png
[2]:assets/数据库-cc73d.png
[1]:assets/数据库-a04c5.png
