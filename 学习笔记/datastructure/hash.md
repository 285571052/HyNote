
<!--toc-->

- [哈希](#哈希)
	- [整数哈希](#整数哈希)
		- [取模](#取模)
			- [方法](#方法)
			- [分析](#分析)
		- [平方取中法](#平方取中法)
			- [方法](#方法-1)
			- [例子](#例子)
			- [分析](#分析-1)
	- [字符串哈希](#字符串哈希)
		- [求和取模](#求和取模)
			- [方法](#方法-2)
			- [分析](#分析-2)
		- [ELF哈希函数](#elf哈希函数)
			- [方法](#方法-3)
			- [实现](#实现)
			- [分析](#分析-3)
		- [其他](#其他)
	- [冲突解决](#冲突解决)
		- [开放式哈希](#开放式哈希)
			- [链表](#链表)
		- [封闭式哈希](#封闭式哈希)
			- [线性探测](#线性探测)
				- [缺点](#缺点)
				- [解决办法](#解决办法)
			- [二次探测](#二次探测)
				- [缺点](#缺点-1)
				- [解决办法](#解决办法-1)
			- [重哈希法](#重哈希法)
				- [例子](#例子-1)
			- [随机探测](#随机探测)
				- [真随机探测](#真随机探测)
				- [伪随机探测](#伪随机探测)
	- [插入过程](#插入过程)
		- [代码](#代码)
	- [查找过程](#查找过程)
		- [代码](#代码-1)
	- [删除](#删除)
		- [墓碑大法](#墓碑大法)
			- [代码](#代码-2)
			- [缺点](#缺点-2)
			- [解决办法](#解决办法-2)
	- [参考代码](#参考代码)
	- [性能分析](#性能分析)

<!-- tocstop -->


# 哈希

## 整数哈希

### 取模

#### 方法

```
h(k) = k % M;
```
#### 分析

这个哈希方法返回值，只取决于数字k的低位，冲突的几率比较大

### 平方取中法

#### 方法
平方之后，取中间的r位
r的取值，取决于M的大小
M是哈希表的大小，（类比取模法的M）

#### 例子
M的大小为16，平方之后，取中间的4位($2^4 = 16$)

#### 分析
哈希函数的返回值 和 这个数字的所有bit都有关，是所有bit参与运算的结果。

## 字符串哈希

### 求和取模

#### 方法
把字符串的所有字符求和再取模

#### 分析
如果字符串比较短，那么字符落的范围会比较集中。不好！

### ELF哈希函数

#### 方法
依次从字符串中取一个字符串来运算，把上次结果循环左移动4bit，再加上当前的字符的值

#### 实现
```{cpp}
int ELF(char *key){
  unsigned long h = 0;
  while(* key){
    h = (h << 4) + *key++;
    unsigned long g = h & 0xF0000000L
    if(g) h^=g>>24;//h的位数超过，
    h &= ~g;
  }
  return h % M;
}
```

#### 分析
能够迅速产生一个很大的数字

### 其他
字符串哈希，大部分情况都类似 进制转换，
把每个字符看作一个数字，当前的哈希值乘以某个进制，再加上当前的字符代表的值。

就像 **1001** 转换成10进制数字，那么就是$1\times 2^0 + 0\times 2^1 + 0\times 2^2 + 1\times 2^3$

字符串哈希就是把上面的 **1001** 换成了每个字符代表的值，$2^x$ 换成了 某个进制的。
这不就是进制转换吗？（虽然有时候字符代表的值比进制还大）

## 冲突解决

### 开放式哈希
通过增加空间来解决问题

#### 链表
对于哈希表的每个位置，都使用一个链表储存

### 封闭式哈希
不增加空间的前提下解决问题（按照一定方法往后探测可以存放的位置）
使用 $p(k,i)$ 表示第i次探测相对于 $h(k)$ 的偏移
则 $pos(k) = ( h(k) + p(k,i) )\%M$

#### 线性探测
往后按照一定间隔探测空位置
$p(k,i) = i * c$ ,c为间隔

##### 缺点
当出现聚集现象的时候，这个现象会不断加剧，效率会越来越低
比如，![1],下一个数据出现在3号位置的概率为 $\frac{4}{11}$。
当3号位置被放数据之后，4号位置的概率为$\frac{5}{11]}$.
数据会连成一片，并且越来越严重

即使在间隔不是1，是其他，但是在相同间隔的情况下也会出现类死 上面的聚集现象

##### 解决办法
二次探测

#### 二次探测
往后探测的距离不是定值
$p(k,i) = i^2$

##### 缺点
如果两个数第一次冲突的位置相同，那么这两个数将有相同的探测序列

##### 解决办法
重哈希法

#### 重哈希法
Double-hash
二次探测的聚集问题，主要是因为 $p(k,i)$ 只和i有关，和k无关，所以只要把 $p(k,i)$ 和 k 关联起来就能解决问题了
这里使用了另外一个哈希函数来关联，所以叫重哈希
$p(k,i) = i \times h_2(k)$
$pos(k) = h(k) + i \times h_2(k)$

##### 例子
已知：
$h(k_1) = 30,h(k_2) = 30$
$h_2(k_1) = 3,h_2(k_2) = 5$
则：
$pos(k_1) = 30,33,36,39,...$
$pos(k_2) = 30,35,40,45,...$

#### 随机探测
##### 真随机探测
这个虽然填进去了，但是后续的查找完全无法进行

##### 伪随机探测
生成一个随机序列，以后根据这个随机序列进行探测

## 插入过程
循环探测，直到找到空的位置
要考虑之前删除过点的位置

### 代码
1. 定义 值：-1 表示初始为空
2. 定义 值：-2 表示为空，但是曾经有过元素

```cpp
const int maxn = 1E6;
int a[maxn];
int pro(int i) {
	return i;
}
int h(int k) {
	return k % n;
}
int pos(int k) {
	for (int i = 0; true; ++i) {
		int p = (h(k) + pro(i)) % n;
		if (a[p] == -1 || a[p] == -2) {
			return p;
		}
	}
}
void add(int k) {
	a[pos(k)] = k;
}
```

## 查找过程
循环探测，直到找到，或者找到空的位置
### 代码
值：-1 表示初始空
注意：哈希表不能存满了，否则会陷入死循环
```cpp
int search(int k) {
	for (int i = 0; true; ++i) {
		int p = (h(k) + pro(i)) % n;
		if (a[p] == -1) {
			return -1;
		}
		else if (a[p] == k) {
			return p;
		}
	}
}
```

## 删除
对于每个位置上的数据，它实际上有两个作用：
1. 作为数据本身，表示它自己
2. 作为其他数据探测路径上的一个节点。
		表示这个位置不能坐，请往后找。
		所以，哈希表的删除操作，不能只是简单的置空。
		数据清除之后，还要能告诉其他节点，这个位置能坐，但是曾经坐过人

### 墓碑大法
实际上就是在原来的数据上作一个简单的标记，表示探测可以往后继续探测，插入可以在这里插入

#### 代码
```cpp
void Hashdelete(int k) {
	for (int i = 0; true; ++i) {
		int p = (h(k) + pro(i)) % n;
		if (a[p] == k) {
			a[p] = -2;
			return;
		}
	}
}
```

#### 缺点
当'墓碑'特别多，但数据特别少的时候，进行查找操作的时候，查找的效率，还是很低

#### 解决办法
定期对 哈希表的（部分）数据进行重新插入操作

## 参考代码
哈希方法：`h(x) = x % n`
探测方法：线性探测`pro(i) = i`
墓碑：值为-1表示空，值为-2表示墓碑
```{cpp}
const int maxn = 1E6;
int a[maxn], n;
int pro(int i) {
	return i;
}
int h(int k) {
	return k % n;
}
int pos(int k) {
	for (int i = 0; true; ++i) {
		int p = (h(k) + pro(i)) % n;
		if (a[p] == -1) {
			return p;
		}
	}
}
void add(int k) {
	a[pos(k)] = k;
}
void Hashdelete(int k) {
	for (int i = 0; true; ++i) {
		int p = (h(k) + pro(i)) % n;
		if (a[p] == k) {
			a[p] = -2;
			return;
		}
	}
}
int search(int k) {
	for (int i = 0; true; ++i) {
		int p = (h(k) + pro(i)) % n;
		if (a[p] == -1) {
			return -1;
		}
		else if (a[p] == k) {
			return p;
		}
	}
}

memset(a, -1, sizeof(a));
```

## 性能分析
1. 哈希表的好坏，取决于哈希函数的取法，和数据本身，当冲突剧烈的时候，效率会大幅度降低
2. 哈希表的效率与空间的利用率有关（时间和空间的矛盾关系）


[1]:assets/hash-d5b5d.png
