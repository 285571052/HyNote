<!--toc-->

- [indexing 索引](#indexing-索引)
	- [索引的好处(必要性)](#索引的好处必要性)
	- [线性索引(Liner index)](#线性索引liner-index)
		- [本质](#本质)
		- [缺点](#缺点)
		- [解决办法](#解决办法)
- [非线性索引(树索引)](#非线性索引树索引)
	- [BST-二叉查找树](#bst-二叉查找树)
		- [优点](#优点)
		- [缺点](#缺点-1)
			- [缺点产生的原因](#缺点产生的原因)
		- [解决办法](#解决办法-1)
	- [2-3Tree](#2-3tree)
	- [B-Tree](#b-tree)
	- [B+Tree](#btree)
		- [B+Tree 和 BTree的区别](#btree-和-btree的区别)
		- [B+Tree 的插入](#btree-的插入)
		- [删除操作](#删除操作)
			- [关键](#关键)
			- [操作](#操作)
			- [时间复杂度](#时间复杂度)

<!-- tocstop -->
# indexing 索引
## 索引的好处(必要性)
1. 支持范围查找( **range query** )
2. 支持多关键字查找( **mutiple key** )

## 线性索引(Liner index)
### 本质
线性索引，按索引index大小，从小到大排序
线性索引的本质：有序数组

### 缺点
1. 如果索引特别大的话，内存可能放不下
2. 线性索引只能支持快速的查找，不能进行快速的update（增加没删除）操作

### 解决办法
1. 建立一个二级索引
		既然所以特别大，那就再做一个 索引 的 索引（二级索引）
		先根据二级索引 提取 需要的部分一级索引
		再根据一级索引 进行 数据的提取
		比如：把一级索引 均分成若干块，提起每一块的最值作为二级索引的值

2. 这个是 Liner index 的性质决定的。
		如果要支持快速update，最好还是用其他更优雅的数据结构（非线性索引，树）

# 非线性索引(树索引)

## BST-二叉查找树
满足：左子树的值 比 根节点小（大），右子树的值始终比 根节点大（小）的树

### 优点
在平衡的情况下，能进行快速的查找，增加，删除操作

### 缺点
随着数据的输入，BST 可能会退化成链表

#### 缺点产生的原因
BST树在向下生长的过程中，容易失控（一直往下生长）。

所以解决的思路有两种:
1. 重新生成新的 平衡的BST树(AVL Tree)
2. 控制树的生长方向(2-3 Tree)

### 解决办法
1. AVL Tree（始终保持BST的平衡）
2. 2-3 Tree（对BST进行扩展）
3. B Tree

## 2-3Tree
见 2-3Tree.md

## B-Tree
## B+Tree
### B+Tree 和 BTree的区别
1. B+Tree 中间节点只保存key，不保存数据
2. 只有叶子节点才保存数据
3. 相同高度的节点 相互连接在一起
4. 中间节点和叶子节点的容量可以不一样
		一般地，叶子节点和中间节点的容量 是 根据硬盘 I/O 一次的的吞吐量来决定的。

### B+Tree 的插入
1. 找到对应的叶子节点的位置（必须到叶子节点，因为B+Tree只有叶子节点才存放数据）
2. 插入数据
		1. 如果 叶子节点还有容量，那么就直接插入
		2. 如果叶子节点没有容量，那么就把这个节点分裂成两个节点

3. 分裂节点
		1. 数据均分
		2. 父节点加入新节点的最小值（假设新节点存的是大值）
		3. 连边
		4. 向上传递最小值，这个在树根分裂的时候可能用得到

4. 父节点重复2，3，4操作

### 删除操作

#### 关键
```
rich:help
poor:merge
```

#### 操作
1. 如果父节点有足够多的值，那么就向兄弟节点借用
		并不是直接借，而是兄弟节点传值给父节点，父节点传值给兄弟节点

2. 如果父节点没有足够的值，那么就把这个节点和兄弟节点合并
		兄弟节点的值不够，不继续向它的兄弟节点借用，否则产生连锁反应

3. 调整父节点的关键字

4. 父节点重复1，2，3，4操作

#### 时间复杂度
插入/删除都是 $\theta = log_rn$
