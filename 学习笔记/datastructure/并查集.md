<!--toc-->

- [并查集](#并查集)
	- [理解](#理解)
		- [时间优化](#时间优化)
		- [空间优化](#空间优化)
	- [优化](#优化)
		- [路径压缩](#路径压缩)
			- [实现](#实现)
		- [加权合并](#加权合并)
			- [实现](#实现-1)
	- [参考代码](#参考代码)

<!-- tocstop -->
# 并查集
本质就是 父指针数组
不过在并查集中，我们不关心父亲是谁，我们只关心祖宗是谁，也就是拥有同一个祖宗的两个节点是在同一个集合内。

实现的时候：我们需要给祖宗节点（没有父亲的那个）做一个标记，这里我们直接使用祖宗节点自己的编号作为标记（就是祖宗的父亲是自己这个情况来表示）

## 理解
实际上，
并查集就是对所有元素进行标记，有相同标记的元素表示在同一个集合中。
判断两个元素是否在一个集合，就是判断标记是否一样。

### 时间优化
合并的过程，就是把一个集合内的元素的标记改成另一个集合的标记。
但是如果合并的时候，集合的每一个元素都修改一次标记，显然是很低效的。
这个时候可以考虑再用一个数组来对标记进行标记，表示两个标记是等价的。这样就只需要修改一下这个新的标记数组进行标记就可以了。

这样实现之后，进行多次合并的话，就会树的形状，树根就表示最终的标记（实际上，这个数组就是父指针数组，这里我们定义当标记数组的标记是自己的时候，表示得到了最终的标记）

### 空间优化
根据上面的算法，用到了两个数组：
第一个数组：元素的标记数组，表示元素属于哪个集合，用$B$表示这个数组
第二个数组：元素的标记的数组，用A表示这个数组

比如，$A[i]$表示i这个标记和$A[i]$这个标记等价。
根据上面的定义，当$A[i] == i$的时候，表示这个标记就是最终的标记。

可以看出，第一个数组进行第一次标记之后，就没有再进行任何操作。
我们判断i是在哪个集合的时候，我们先取$B[i]$(记为j)，然后再不断地重复取$j = A[j]$，直到$j == A[j]$。

如果我们定义初始的状态为$h(j)$，那么我们完全可以用一个函数代替B数组，这样就可以去掉这个数组的空间

（如果初始状态是其他的情况，我们完全可以通过不断地合并来达到这个状态）

下面的代码，就是使用 $h(j) = j$这个方法来代替B

## 优化
由于我们并不关心父亲节点是谁，我们只关心祖宗节点是谁，所以每次访问的时候，都需要沿着父指针数组往前找祖宗节点。

如果从节点到达祖宗节点的路径很长，那么代价就会很大，所以我们想要把路径尽可能短。
### 路径压缩
方法就是把节点的父指针直接指向祖宗节点（这样就无法保存父子节点的关系，但是我们并不关心这个）

在查找的时候我们可以进行优化

#### 实现
```{cpp}
int fnd(int x) {
	return x == fa[x] ? x : (fa[x] = fnd(fa[x]));
}
```

### 加权合并
合并两棵树的时候，把节点少多的树根 设置成 合并后的树的根，这样合并之后的树的平均高度就尽可能小，路径的最大值就是树的高度 - 1，所以路径也就越小。

#### 实现
给每一个节点增加一个 权值，表示子节点的个数，合并的时候根据权值选择谁作为父节点，同时更新一下权值
```{cpp}
int uni(int x,int y){
        x = fnd(x);y = fnd(y);
        if(x == y)      return 0;
        if(mrank[x] < mrank[y]){
                fa[x] = y;
        }else {
                fa[y] = x;
                if(mrank[x] == mrank[y])        ++mrank[x];  
        }
        return 1;
}
```

## 参考代码
使用并查集之前要初始化(调用 'ini')
```{cpp}
const int maxn = 1000 + 100;
int fa[maxn],mrank[maxn];
void ini(int n){
        memset(mrank,0,sizeof(mrank));
        for(int i = 0; i <= n;++i){
                fa[i] = i;
        }
}
int fnd(int x){
        return x ==fa[x]?x:fa[x] = fnd(fa[x]);
}

//直接合并
void uni2(int x,int y){
	fa[fnd(x)] = fnd(y);
}

//加权合并
int uni(int x,int y){
        x = fnd(x);y = fnd(y);
        if(x == y)      return 0;
        if(mrank[x] < mrank[y]){
                fa[x] = y;
        }else {
                fa[y] = x;
                if(mrank[x] == mrank[y])        ++mrank[x];  
        }
        return 1;
}
```
