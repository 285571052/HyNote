[2016-04-23][C++类模板的一些事儿]
###定义(关于类模板和模板类)
* ####类模板:在类里面使用了 模板类型,即满足如下结构就是类模板
 ```
template <typename T>
class Array{
        T* p;
}  ;
 ```
* ####模板类:类模板实例化之后的对象就叫模板类

###使用
* ####实例化必须指定类型,
 * 通过 类名后面加上 `<类型>` 来指明类型
 ```
Array<int> a;
 ```
* ####注意
 * 没有指定类型是不能实例化的,
 * 没有实例化的变量是不能使用的!!!
```
template <typename T> T a;
cin>>a;//'ERROR:a还没有实例化',
```
  * ####同时上面的T a;这种用法只能出现在类里面,因为类的定理还没有实例化,在类外面是不允许的!!!

###运算符的重载
* ####普通运算符的重载
 * 和其他类的重载一样
* ####<< 和 >> 的重载
 * #####如果和其他类一样的重载会提示类似下面的错误:
 ```
error C2679: 二进制“<<”: 没有找到接受“Array<T>”类型的右操作数的运算符(或没有可接受的转换)
 ```
   1. 就是声明的模板T没有起到作用,无法识别,这里原因由于能力问题不能想通,但是能找到解决办法,(管他为什么,学会正确的姿势就OK了)
   2. 既然不能识别,那么我们就让它识别到就OK了,
   3. 方法就是把函数重载成类外的函数(如果要访问private,就声明为友元),
   4. 然后声明变量的时候定义Array的类型即可(看下面Array<T> a,而不是Array a)
    * 这里就是把<<重载的函数声明称函数模板
  ```
        friend ostream & operator<<(ostream &os,const Array<T> & a){
                os<<"hongyang\n";
                return os;
        }
  ```
    * #####还有个问题,就是必须把这整个友元函数的声明和定义都写在类里面才对
    * 声明写在里面,定义写带类外面,是错误的!!!
      * 原因是,如果在类外面实现的话,外面的T和里面的T就不是同一个T了,相当于定义了一个新的模板T(和类里面的T不是一个东西了),
      * 有点绕,看不懂就跳过把,学会正确的姿势就好
    * 如果硬是要在类外面定义的话,也不是没有办法,就是在这个函数里面不使用类的数据成员,通过使用类的成员函数来达到访问数据的目的
 ```
        friend ostream & operator<<(ostream &os,const Array<T> & a){
                // os<<a.Date;错误!!!
                os<<a.getDate();
                return os;
        }
 ```

资料:
http://www.cnblogs.com/xkfz007/articles/2534322.html
